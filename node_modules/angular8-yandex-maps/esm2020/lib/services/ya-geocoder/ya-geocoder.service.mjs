import { Injectable } from '@angular/core';
import { switchMap } from 'rxjs/operators';
import { from, Observable } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "../ya-api-loader/ya-api-loader.service";
/**
 * The `YaGeocoder` service wraps `ymaps.geocode` static function from the Yandex.Maps API.
 *
 * @example
 * ```ts
 * import { YaGeocoderService } from 'angular8-yandex-maps';
 *
 * export class AppComponent {
 *   constructor(private yaGeocoderService: YaGeocoderService) {
 *     this.yaGeocoderService.geocode('Moscow')
 *       .subscribe(v => console.log(v))
 *   }
 * }
 * ```
 */
export class YaGeocoderService {
    constructor(_ngZone, _yaApiLoaderService) {
        this._ngZone = _ngZone;
        this._yaApiLoaderService = _yaApiLoaderService;
    }
    /**
     * Processes geocoding requests.
     * @param request The address for which coordinates need to be obtained (forward geocoding), or the coordinates for which the address needs to be determined (reverse geocoding).
     * @param options Options.
     */
    geocode(request, options) {
        return this._yaApiLoaderService.load().pipe(switchMap(() => from(ymaps.geocode(request, options))), switchMap((result) => new Observable((observer) => {
            this._ngZone.run(() => {
                observer.next(result);
                observer.complete();
            });
        })));
    }
}
YaGeocoderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: YaGeocoderService, deps: [{ token: i0.NgZone }, { token: i1.YaApiLoaderService }], target: i0.ɵɵFactoryTarget.Injectable });
YaGeocoderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: YaGeocoderService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: YaGeocoderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i1.YaApiLoaderService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWEtZ2VvY29kZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXI4LXlhbmRleC1tYXBzL3NyYy9saWIvc2VydmljZXMveWEtZ2VvY29kZXIveWEtZ2VvY29kZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFVLE1BQU0sZUFBZSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQzs7O0FBR3hDOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBSUgsTUFBTSxPQUFPLGlCQUFpQjtJQUM1QixZQUNtQixPQUFlLEVBQ2YsbUJBQXVDO1FBRHZDLFlBQU8sR0FBUCxPQUFPLENBQVE7UUFDZix3QkFBbUIsR0FBbkIsbUJBQW1CLENBQW9CO0lBQ3ZELENBQUM7SUFFSjs7OztPQUlHO0lBQ0gsT0FBTyxDQUFDLE9BQTBCLEVBQUUsT0FBK0I7UUFDakUsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUN6QyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFDdEQsU0FBUyxDQUNQLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FDVCxJQUFJLFVBQVUsQ0FBUyxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ2xDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTtnQkFDcEIsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDdEIsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3RCLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQ0wsQ0FDRixDQUFDO0lBQ0osQ0FBQzs7OEdBeEJVLGlCQUFpQjtrSEFBakIsaUJBQWlCLGNBRmhCLE1BQU07MkZBRVAsaUJBQWlCO2tCQUg3QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgZnJvbSwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgWWFBcGlMb2FkZXJTZXJ2aWNlIH0gZnJvbSAnLi4veWEtYXBpLWxvYWRlci95YS1hcGktbG9hZGVyLnNlcnZpY2UnO1xuXG4vKipcbiAqIFRoZSBgWWFHZW9jb2RlcmAgc2VydmljZSB3cmFwcyBgeW1hcHMuZ2VvY29kZWAgc3RhdGljIGZ1bmN0aW9uIGZyb20gdGhlIFlhbmRleC5NYXBzIEFQSS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IFlhR2VvY29kZXJTZXJ2aWNlIH0gZnJvbSAnYW5ndWxhcjgteWFuZGV4LW1hcHMnO1xuICpcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHlhR2VvY29kZXJTZXJ2aWNlOiBZYUdlb2NvZGVyU2VydmljZSkge1xuICogICAgIHRoaXMueWFHZW9jb2RlclNlcnZpY2UuZ2VvY29kZSgnTW9zY293JylcbiAqICAgICAgIC5zdWJzY3JpYmUodiA9PiBjb25zb2xlLmxvZyh2KSlcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBZYUdlb2NvZGVyU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgX25nWm9uZTogTmdab25lLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgX3lhQXBpTG9hZGVyU2VydmljZTogWWFBcGlMb2FkZXJTZXJ2aWNlLFxuICApIHt9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBnZW9jb2RpbmcgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBhZGRyZXNzIGZvciB3aGljaCBjb29yZGluYXRlcyBuZWVkIHRvIGJlIG9idGFpbmVkIChmb3J3YXJkIGdlb2NvZGluZyksIG9yIHRoZSBjb29yZGluYXRlcyBmb3Igd2hpY2ggdGhlIGFkZHJlc3MgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZCAocmV2ZXJzZSBnZW9jb2RpbmcpLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgZ2VvY29kZShyZXF1ZXN0OiBzdHJpbmcgfCBudW1iZXJbXSwgb3B0aW9ucz86IHltYXBzLklHZW9jb2RlT3B0aW9ucyk6IE9ic2VydmFibGU8b2JqZWN0PiB7XG4gICAgcmV0dXJuIHRoaXMuX3lhQXBpTG9hZGVyU2VydmljZS5sb2FkKCkucGlwZShcbiAgICAgIHN3aXRjaE1hcCgoKSA9PiBmcm9tKHltYXBzLmdlb2NvZGUocmVxdWVzdCwgb3B0aW9ucykpKSxcbiAgICAgIHN3aXRjaE1hcChcbiAgICAgICAgKHJlc3VsdCkgPT5cbiAgICAgICAgICBuZXcgT2JzZXJ2YWJsZTxvYmplY3Q+KChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLFxuICAgICAgKSxcbiAgICApO1xuICB9XG59XG4iXX0=