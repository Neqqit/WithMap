{"version":3,"file":"angular8-yandex-maps.mjs","sources":["../../../projects/angular8-yandex-maps/src/lib/typings/yandex-maps/index.ts","../../../projects/angular8-yandex-maps/src/lib/services/ya-api-loader/ya-api-loader.service.ts","../../../projects/angular8-yandex-maps/src/lib/event-manager.ts","../../../projects/angular8-yandex-maps/src/lib/utils/generate-random-id.ts","../../../projects/angular8-yandex-maps/src/lib/components/ya-map/ya-map.component.ts","../../../projects/angular8-yandex-maps/src/lib/components/ya-geoobject/ya-geoobject.directive.ts","../../../projects/angular8-yandex-maps/src/lib/components/ya-placemark/ya-placemark.directive.ts","../../../projects/angular8-yandex-maps/src/lib/components/ya-clusterer/ya-clusterer.component.ts","../../../projects/angular8-yandex-maps/src/lib/components/ya-control/ya-control.directive.ts","../../../projects/angular8-yandex-maps/src/lib/components/ya-multiroute/ya-multiroute.directive.ts","../../../projects/angular8-yandex-maps/src/lib/components/ya-panorama/ya-panorama.directive.ts","../../../projects/angular8-yandex-maps/src/lib/angular-yandex-maps.module.ts","../../../projects/angular8-yandex-maps/src/lib/services/ya-geocoder/ya-geocoder.service.ts","../../../projects/angular8-yandex-maps/src/public-api.ts","../../../projects/angular8-yandex-maps/src/angular8-yandex-maps.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/ban-types */\n/* eslint-disable @typescript-eslint/brace-style */\n/* eslint-disable @typescript-eslint/explicit-member-accessibility */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-shadow */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-use-before-define */\n/* eslint-disable max-classes-per-file */\n\n/**\n * Type definitions for Yandex.Maps.\n * Due to inactivity the typings were copied and improved from the DefinitelyTyped repository.\n * Definitions by: Delagen <https://github.com/Delagen> / gastwork13 <https://github.com/gastwork13>.\n * @link https://www.npmjs.com/package/@types/yandex-maps\n * @link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/concepts/About.html\n */\ndeclare namespace ymaps {\n  interface IClassConstructor<T> {\n    superclass: any;\n\n    new (): T;\n  }\n\n  type ControlSingleKey =\n    | 'fullscreenControl'\n    | 'geolocationControl'\n    | 'routeEditor'\n    | 'rulerControl'\n    | 'searchControl'\n    | 'trafficControl'\n    | 'typeSelector'\n    | 'zoomControl'\n    | 'routeButtonControl'\n    | 'routePanelControl';\n\n  type ControlSetKey =\n    | 'smallMapDefaultSet'\n    | 'mediumMapDefaultSet'\n    | 'largeMapDefaultSet'\n    | 'default';\n\n  type ControlKey = ControlSingleKey | ControlSetKey;\n\n  type OverlayKey =\n    | 'default#placemark'\n    | 'default#pin'\n    | 'default#circle'\n    | 'default#rectangle'\n    | 'default#polyline'\n    | 'default#polygon'\n    | 'hotspot#placemark'\n    | 'hotspot#circle'\n    | 'hotspot#rectangle'\n    | 'hotspot#polyline'\n    | 'hotspot#polygon'\n    | 'html#balloon'\n    | 'html#hint'\n    | 'html#placemark'\n    | 'html#rectangle'\n    | string\n    | IClassConstructor<IOverlay>\n    | ((\n        geometry: IPixelLineStringGeometry,\n        data: IDataManager | object,\n        options: object,\n      ) => Promise<string | IClassConstructor<IOverlay>>);\n\n  type InteractivityModelKey =\n    | 'default#opaque'\n    | 'default#geoObject'\n    | 'default#layer'\n    | 'default#transparent'\n    | 'default#silent'\n    | string;\n\n  type PresetWithTextKey =\n    | 'islands#blueIcon'\n    | 'islands#darkGreenIcon'\n    | 'islands#redIcon'\n    | 'islands#violetIcon'\n    | 'islands#darkOrangeIcon'\n    | 'islands#blackIcon'\n    | 'islands#nightIcon'\n    | 'islands#yellowIcon'\n    | 'islands#darkBlueIcon'\n    | 'islands#greenIcon'\n    | 'islands#pinkIcon'\n    | 'islands#orangeIcon'\n    | 'islands#grayIcon'\n    | 'islands#lightBlueIcon'\n    | 'islands#brownIcon'\n    | 'islands#oliveIcon';\n\n  type PresetWithTextStretchyKey =\n    | 'islands#blueStretchyIcon'\n    | 'islands#darkGreenStretchyIcon'\n    | 'islands#redStretchyIcon'\n    | 'islands#violetStretchyIcon'\n    | 'islands#darkOrangeStretchyIcon'\n    | 'islands#blackStretchyIcon'\n    | 'islands#nightStretchyIcon'\n    | 'islands#yellowStretchyIcon'\n    | 'islands#darkBlueStretchyIcon'\n    | 'islands#greenStretchyIcon'\n    | 'islands#pinkStretchyIcon'\n    | 'islands#orangeStretchyIcon'\n    | 'islands#grayStretchyIcon'\n    | 'islands#lightBlueStretchyIcon'\n    | 'islands#brownStretchyIcon'\n    | 'islands#oliveStretchyIcon';\n\n  type PresetDotKey =\n    | 'islands#blueDotIcon'\n    | 'islands#darkGreenDotIcon'\n    | 'islands#redDotIcon'\n    | 'islands#violetDotIcon'\n    | 'islands#darkOrangeDotIcon'\n    | 'islands#blackDotIcon'\n    | 'islands#nightDotIcon'\n    | 'islands#yellowDotIcon'\n    | 'islands#darkBlueDotIcon'\n    | 'islands#greenDotIcon'\n    | 'islands#pinkDotIcon'\n    | 'islands#orangeDotIcon'\n    | 'islands#grayDotIcon'\n    | 'islands#lightBlueDotIcon'\n    | 'islands#brownDotIcon'\n    | 'islands#oliveDotIcon';\n\n  type PresetCircleKey =\n    | 'islands#blueCircleIcon'\n    | 'islands#darkGreenCircleIcon'\n    | 'islands#redCircleIcon'\n    | 'islands#violetCircleIcon'\n    | 'islands#darkOrangeCircleIcon'\n    | 'islands#blackCircleIcon'\n    | 'islands#nightCircleIcon'\n    | 'islands#yellowCircleIcon'\n    | 'islands#darkBlueCircleIcon'\n    | 'islands#greenCircleIcon'\n    | 'islands#pinkCircleIcon'\n    | 'islands#orangeCircleIcon'\n    | 'islands#grayCircleIcon'\n    | 'islands#lightBlueCircleIcon'\n    | 'islands#brownCircleIcon'\n    | 'islands#oliveCircleIcon';\n\n  type PresetCircleDotKey =\n    | 'islands#blueCircleDotIcon'\n    | 'islands#darkGreenCircleDotIcon'\n    | 'islands#redCircleDotIcon'\n    | 'islands#violetCircleDotIcon'\n    | 'islands#darkOrangeCircleDotIcon'\n    | 'islands#blackCircleDotIcon'\n    | 'islands#nightCircleDotIcon'\n    | 'islands#yellowCircleDotIcon'\n    | 'islands#darkBlueCircleDotIcon'\n    | 'islands#greenCircleDotIcon'\n    | 'islands#pinkCircleDotIcon'\n    | 'islands#orangeCircleDotIcon'\n    | 'islands#grayCircleDotIcon'\n    | 'islands#lightBlueCircleDotIcon'\n    | 'islands#brownCircleDotIcon'\n    | 'islands#oliveCircleDotIcon';\n\n  type PresetWithIconKey =\n    | 'islands#blueAirportIcon'\n    | 'islands#blueAttentionIcon'\n    | 'islands#blueAutoIcon'\n    | 'islands#blueBarIcon'\n    | 'islands#blueBarberIcon'\n    | 'islands#blueBeachIcon'\n    | 'islands#blueBicycleIcon'\n    | 'islands#blueBicycle2Icon'\n    | 'islands#blueBookIcon'\n    | 'islands#blueCarWashIcon'\n    | 'islands#blueChristianIcon'\n    | 'islands#blueCinemaIcon'\n    | 'islands#blueCircusIcon'\n    | 'islands#blueCourtIcon'\n    | 'islands#blueDeliveryIcon'\n    | 'islands#blueDiscountIcon'\n    | 'islands#blueDogIcon'\n    | 'islands#blueEducationIcon'\n    | 'islands#blueEntertainmentCenterIcon'\n    | 'islands#blueFactoryIcon'\n    | 'islands#blueFamilyIcon'\n    | 'islands#blueFashionIcon'\n    | 'islands#blueFoodIcon'\n    | 'islands#blueFuelStationIcon'\n    | 'islands#blueGardenIcon'\n    | 'islands#blueGovernmentIcon'\n    | 'islands#blueHeartIcon'\n    | 'islands#blueHomeIcon'\n    | 'islands#blueHotelIcon'\n    | 'islands#blueHydroIcon'\n    | 'islands#blueInfoIcon'\n    | 'islands#blueLaundryIcon'\n    | 'islands#blueLeisureIcon'\n    | 'islands#blueMassTransitIcon'\n    | 'islands#blueMedicalIcon'\n    | 'islands#blueMoneyIcon'\n    | 'islands#blueMountainIcon'\n    | 'islands#blueNightClubIcon'\n    | 'islands#blueObservationIcon'\n    | 'islands#blueParkIcon'\n    | 'islands#blueParkingIcon'\n    | 'islands#bluePersonIcon'\n    | 'islands#bluePocketIcon'\n    | 'islands#bluePoolIcon'\n    | 'islands#bluePostIcon'\n    | 'islands#blueRailwayIcon'\n    | 'islands#blueRapidTransitIcon'\n    | 'islands#blueRepairShopIcon'\n    | 'islands#blueRunIcon'\n    | 'islands#blueScienceIcon'\n    | 'islands#blueShoppingIcon'\n    | 'islands#blueSouvenirsIcon'\n    | 'islands#blueSportIcon'\n    | 'islands#blueStarIcon'\n    | 'islands#blueTheaterIcon'\n    | 'islands#blueToiletIcon'\n    | 'islands#blueUnderpassIcon'\n    | 'islands#blueVegetationIcon'\n    | 'islands#blueVideoIcon'\n    | 'islands#blueWasteIcon'\n    | 'islands#blueWaterParkIcon'\n    | 'islands#blueWaterwayIcon'\n    | 'islands#blueWorshipIcon'\n    | 'islands#blueZooIcon';\n\n  type PresetWithIconCircleKey =\n    | 'islands#blueHomeCircleIcon'\n    | 'islands#blueScienceCircleIcon'\n    | 'islands#blueAirportCircleIcon'\n    | 'islands#blueAttentionCircleIcon'\n    | 'islands#blueAutoCircleIcon'\n    | 'islands#blueBarCircleIcon'\n    | 'islands#blueBarberCircleIcon'\n    | 'islands#blueBeachCircleIcon'\n    | 'islands#blueBicycleCircleIcon'\n    | 'islands#blueBicycle2CircleIcon'\n    | 'islands#blueBookCircleIcon'\n    | 'islands#blueCarWashCircleIcon'\n    | 'islands#blueChristianCircleIcon'\n    | 'islands#blueCinemaCircleIcon'\n    | 'islands#blueCircusCircleIcon'\n    | 'islands#blueCourtCircleIcon'\n    | 'islands#blueDeliveryCircleIcon'\n    | 'islands#blueDiscountCircleIcon'\n    | 'islands#blueDogCircleIcon'\n    | 'islands#blueEducationCircleIcon'\n    | 'islands#blueEntertainmentCenterCircleIcon'\n    | 'islands#blueFactoryCircleIcon'\n    | 'islands#blueFamilyCircleIcon'\n    | 'islands#blueFashionCircleIcon'\n    | 'islands#blueFoodCircleIcon'\n    | 'islands#blueFuelStationCircleIcon'\n    | 'islands#blueGardenCircleIcon'\n    | 'islands#blueGovernmentCircleIcon'\n    | 'islands#blueHeartCircleIcon'\n    | 'islands#blueHotelCircleIcon'\n    | 'islands#blueHydroCircleIcon'\n    | 'islands#blueInfoCircleIcon'\n    | 'islands#blueLaundryCircleIcon'\n    | 'islands#blueLeisureCircleIcon'\n    | 'islands#blueMassTransitCircleIcon'\n    | 'islands#blueMedicalCircleIcon'\n    | 'islands#blueMoneyCircleIcon'\n    | 'islands#blueMountainCircleIcon'\n    | 'islands#blueNightClubCircleIcon'\n    | 'islands#blueObservationCircleIcon'\n    | 'islands#blueParkCircleIcon'\n    | 'islands#blueParkingCircleIcon'\n    | 'islands#bluePersonCircleIcon'\n    | 'islands#bluePocketCircleIcon'\n    | 'islands#bluePoolCircleIcon'\n    | 'islands#bluePostCircleIcon'\n    | 'islands#blueRailwayCircleIcon'\n    | 'islands#blueRapidTransitCircleIcon'\n    | 'islands#blueRepairShopCircleIcon'\n    | 'islands#blueRunCircleIcon'\n    | 'islands#blueShoppingCircleIcon'\n    | 'islands#blueSouvenirsCircleIcon'\n    | 'islands#blueSportCircleIcon'\n    | 'islands#blueStarCircleIcon'\n    | 'islands#blueTheaterCircleIcon'\n    | 'islands#blueToiletCircleIcon'\n    | 'islands#blueUnderpassCircleIcon'\n    | 'islands#blueVegetationCircleIcon'\n    | 'islands#blueVideoCircleIcon'\n    | 'islands#blueWasteCircleIcon'\n    | 'islands#blueWaterParkCircleIcon'\n    | 'islands#blueWaterwayCircleIcon'\n    | 'islands#blueWorshipCircleIcon'\n    | 'islands#blueZooCircleIcon';\n\n  type PresetPictogramKey = 'islands#geolocationIcon';\n\n  type PresetClusterKey =\n    | 'islands#blueClusterIcons'\n    | 'islands#invertedBlueClusterIcons'\n    | 'islands#redClusterIcons'\n    | 'islands#invertedRedClusterIcons'\n    | 'islands#darkOrangeClusterIcons'\n    | 'islands#invertedDarkOrangeClusterIcons'\n    | 'islands#nightClusterIcons'\n    | 'islands#invertedNightClusterIcons'\n    | 'islands#darkBlueClusterIcons'\n    | 'islands#invertedDarkBlueClusterIcons'\n    | 'islands#pinkClusterIcons'\n    | 'islands#invertedPinkClusterIcons'\n    | 'islands#grayClusterIcons'\n    | 'islands#invertedGrayClusterIcons'\n    | 'islands#brownClusterIcons'\n    | 'islands#invertedBrownClusterIcons'\n    | 'islands#darkGreenClusterIcons'\n    | 'islands#invertedDarkGreenClusterIcons'\n    | 'islands#violetClusterIcons'\n    | 'islands#invertedVioletClusterIcons'\n    | 'islands#blackClusterIcons'\n    | 'islands#invertedBlackClusterIcons'\n    | 'islands#yellowClusterIcons'\n    | 'islands#invertedYellowClusterIcons'\n    | 'islands#greenClusterIcons'\n    | 'islands#invertedGreenClusterIcons'\n    | 'islands#orangeClusterIcons'\n    | 'islands#invertedOrangeClusterIcons'\n    | 'islands#lightBlueClusterIcons'\n    | 'islands#invertedLightBlueClusterIcons'\n    | 'islands#oliveClusterIcons'\n    | 'islands#invertedOliveClusterIcons';\n\n  type PresetKey =\n    | PresetWithTextKey\n    | PresetWithTextStretchyKey\n    | PresetDotKey\n    | PresetCircleKey\n    | PresetCircleDotKey\n    | PresetWithIconKey\n    | PresetWithIconCircleKey\n    | PresetPictogramKey\n    | PresetClusterKey\n    | string;\n\n  type IconLayoutKey = 'default#image' | 'default#imageWithContent' | string;\n\n  type ClusterLayoutKey =\n    | 'cluster#balloonTwoColumns'\n    | 'cluster#balloonCarousel'\n    | 'cluster#balloonAccordion'\n    | string;\n\n  type ClusterContentLayoutKey =\n    | 'cluster#balloonTwoColumnsItemContent'\n    | 'cluster#balloonCarouselItemContent'\n    | 'cluster#balloonAccordionItemContent'\n    | string;\n\n  type EventMap = GlobalEventHandlersEventMap;\n\n  namespace behavior {\n    class DblClickZoom implements IBehavior {\n      constructor(options?: IDblClickZoomOptions);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      disable(): void;\n\n      enable(): void;\n\n      isEnabled(): boolean;\n\n      getParent(): IControlParent | null;\n\n      setParent(parent: IControlParent): this;\n    }\n\n    interface IDblClickZoomOptions extends IMapMarginOptions {\n      centering?: boolean;\n      duration?: number;\n    }\n\n    class Drag implements IBehavior {\n      constructor(options?: IDragOptions);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      disable(): void;\n\n      enable(): void;\n\n      isEnabled(): boolean;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n    }\n\n    interface IDragOptions {\n      actionCursor?: string;\n      cursor?: string;\n      inertia?: boolean;\n      inertiaDuration?: number;\n      tremor?: number;\n    }\n\n    class LeftMouseButtonMagnifier implements IBehavior {\n      constructor(options?: ILeftMouseButtonMagnifierOptions);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      disable(): void;\n\n      enable(): void;\n\n      isEnabled(): boolean;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n    }\n\n    interface ILeftMouseButtonMagnifierOptions {\n      actionCursor?: string;\n      cursor?: string;\n      duration?: number;\n    }\n\n    class MultiTouch implements IBehavior {\n      constructor(options?: IMultiTouchOptions);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      disable(): void;\n\n      enable(): void;\n\n      isEnabled(): boolean;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n    }\n\n    interface IMultiTouchOptions {\n      tremor?: number;\n    }\n\n    class RightMouseButtonMagnifier implements IBehavior {\n      constructor(options?: IRightMouseButtonMagnifierOptions);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      disable(): void;\n\n      enable(): void;\n\n      isEnabled(): boolean;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n    }\n\n    interface IRightMouseButtonMagnifierOptions {\n      actionCursor?: string;\n      duration?: number;\n    }\n\n    class RouteEditor implements IBehavior {\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      disable(): void;\n\n      enable(): void;\n\n      isEnabled(): boolean;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n\n      getRoute(): router.Route;\n\n      getState(): string;\n\n      setState(state: string | null): void;\n    }\n\n    class Ruler implements IBehavior {\n      constructor(options?: IRulerOptions);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      disable(): void;\n\n      enable(): void;\n\n      isEnabled(): boolean;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n\n      close(): boolean;\n\n      getState(): string;\n\n      setState(state: string | null): void;\n    }\n\n    interface IRulerOptions {\n      balloonAutoPan?: boolean;\n    }\n\n    class ScrollZoom implements IBehavior {\n      constructor(options?: IScrollZoomOptions);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      disable(): void;\n\n      enable(): void;\n\n      isEnabled(): boolean;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n    }\n\n    interface IScrollZoomOptions {\n      maximumDelta?: number;\n      speed?: number;\n    }\n\n    const storage: util.Storage;\n  }\n\n  namespace clusterer {\n    class Balloon implements IBalloonManager<Clusterer> {\n      constructor(clusterer: Clusterer);\n\n      events: IEventManager;\n\n      autoPan(): Promise<Clusterer>;\n\n      close(force?: boolean): Promise<Clusterer>;\n\n      destroy(): void;\n\n      getData(): object | null;\n\n      getOptions(): IOptionManager | null;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getPosition(): number[] | null;\n\n      isOpen(): boolean;\n\n      open(\n        position?: number[],\n        data?: object | string | HTMLElement,\n        options?: object,\n      ): Promise<Clusterer>;\n\n      setData(data: object | string | HTMLElement): Promise<Clusterer>;\n\n      setOptions(options: object): Promise<Clusterer>;\n\n      setPosition(position: number[]): Promise<Clusterer>;\n    }\n\n    class Hint implements IHintManager<Clusterer> {\n      constructor(clusterer: Clusterer);\n\n      events: IEventManager;\n\n      close(force?: boolean): Promise<Clusterer>;\n\n      destroy(): void;\n\n      getData(): object | null;\n\n      getOptions(): IOptionManager | null;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getPosition(): number[] | null;\n\n      isOpen(): boolean;\n\n      open(\n        position?: number[],\n        data?: object | string | HTMLElement,\n        options?: object,\n      ): Promise<Clusterer>;\n\n      setData(data: object | string | HTMLElement): Promise<Clusterer>;\n\n      setOptions(options: object): Promise<Clusterer>;\n\n      setPosition(position: number[]): Promise<Clusterer>;\n    }\n  }\n\n  namespace collection {\n    class Item implements IChildOnMap, ICustomizable, IEventEmitter, IParentOnMap {\n      constructor(options?: object);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n\n      getMap(): Map;\n\n      onAddToMap(map: Map): void;\n\n      onRemoveFromMap(oldMap: Map): void;\n    }\n  }\n\n  namespace control {\n    class Button implements ICustomizable, ISelectableControl {\n      constructor(parameters?: IButtonParameters | string);\n\n      options: IOptionManager;\n\n      events: IEventManager;\n\n      data: data.Manager;\n\n      state: data.Manager;\n\n      deselect(): void;\n\n      disable(): void;\n\n      enable(): void;\n\n      isEnabled(): boolean;\n\n      isSelected(): boolean;\n\n      select(): void;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n    }\n\n    interface IBaseButtonParametersOptions {\n      adjustMapMargin?: boolean;\n      float?: 'none' | 'left' | 'right';\n      floatIndex?: number;\n      layout?: IClassConstructor<ISelectableControlLayout> | string;\n      maxWidth?: number[][] | number[] | number;\n      position?: {\n        bottom?: number | string;\n        left?: number | string;\n        right?: number | string;\n        top?: number | string;\n      };\n      visible?: boolean;\n    }\n\n    interface IButtonParameters {\n      data?: {\n        content?: string;\n        image?: string;\n        title?: string;\n      };\n      options?: IBaseButtonParametersOptions & {\n        selectOnClick?: boolean;\n        size?: 'auto' | 'small' | 'medium' | 'large';\n      };\n      state?: {\n        enabled?: boolean;\n        selected?: boolean;\n      };\n    }\n\n    class FullscreenControl extends Button {\n      constructor(parameters?: IFullscreenControlParameters);\n\n      enterFullscreen(): void;\n\n      exitFullscreen(): void;\n    }\n\n    interface IFullscreenControlParameters {\n      data?: {\n        title?: string;\n      };\n      options?: IBaseButtonParametersOptions & {\n        collapseOnBlur?: boolean;\n        expandOnClick?: boolean;\n        popupFloat?: 'left' | 'right';\n      };\n      state?: {\n        expanded?: boolean;\n      };\n    }\n\n    class GeolocationControl extends Button {\n      constructor(parameters?: IGeolocationControlParameters);\n    }\n\n    interface IGeolocationControlParameters extends IButtonParameters {\n      data?: {\n        image?: string;\n        title?: string;\n      };\n      options?: IBaseButtonParametersOptions;\n    }\n\n    class ListBox implements ICollection, IControl, ICustomizable {\n      constructor(parameters?: IListBoxParameters);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      data: data.Manager;\n\n      state: data.Manager;\n\n      add(object: object): this;\n\n      getIterator(): IIterator;\n\n      remove(object: object): this;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n    }\n\n    interface IListBoxParameters extends IButtonParameters {\n      options?: IBaseButtonParametersOptions & {\n        noPlacemark?: boolean;\n      };\n    }\n\n    class ListBoxItem implements ICustomizable, ISelectableControl {\n      constructor(parameters?: IListBoxItemParameters);\n\n      options: IOptionManager;\n\n      events: IEventManager;\n\n      data: data.Manager;\n\n      state: data.Manager;\n\n      deselect(): void;\n\n      disable(): void;\n\n      enable(): void;\n\n      isEnabled(): boolean;\n\n      isSelected(): boolean;\n\n      select(): void;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n\n      getMap(): Map;\n    }\n\n    interface IListBoxItemParameters {\n      data?: {\n        content?: string;\n      };\n      options?: {\n        layout?: string | IClassConstructor<ISelectableControlLayout>;\n        selectableLayout?: string | IClassConstructor<ISelectableControlLayout>;\n        selectOnClick?: boolean;\n        separatorLayout?: string | IClassConstructor<ISelectableControlLayout>;\n        type?: 'selectable' | 'separator';\n        visible?: boolean;\n      };\n      state?: {\n        selected?: boolean;\n      };\n    }\n\n    class Manager {\n      constructor(map: Map, controls?: Array<string | IControl>, options?: IManagerOptions);\n\n      events: event.Manager;\n\n      options: option.Manager;\n\n      state: data.Manager;\n\n      add(control: IControl | ControlKey, options?: IManagerControlOptions): this;\n\n      each(callback: (control: IControl) => void, context?: object): this;\n\n      get(index: number | string): IControl | null;\n\n      getChildElement(control: IControl): Promise<HTMLElement>;\n\n      getContainer(): HTMLElement;\n\n      getMap(): Map;\n\n      indexOf(childToFind: IControl | string): number;\n\n      remove(control: IControl | string): this;\n    }\n\n    interface IManagerOptions {\n      margin?: number;\n      pane?: IPane;\n      states?: string[];\n    }\n\n    interface IManagerControlOptions {\n      float?: 'none' | 'left' | 'right';\n      floatIndex?: number;\n      position?: {\n        bottom?: number | string;\n        left?: number | string;\n        right?: number | string;\n        top?: number | string;\n      };\n    }\n\n    class RouteButton implements IControl, ICustomizable {\n      constructor(parameters?: IRouteButtonParameters);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      routePanel: IRoutePanel;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n    }\n\n    interface IRouteButtonParameters {\n      options?: {\n        adjustMapMargin?: boolean;\n        collapseOnBlur?: boolean;\n        float?: 'none' | 'left' | 'right';\n        floatIndex?: number;\n        popupAnimate?: boolean;\n        popupFloat?: 'auto' | 'left' | 'right';\n        popupWidth?: string;\n        position?: {\n          bottom?: number | string;\n          left?: number | string;\n          right?: number | string;\n          top?: number | string;\n        };\n        size?: 'auto' | 'small' | 'medium' | 'large';\n        visible?: boolean;\n      };\n      state?: {\n        expanded?: boolean;\n      };\n    }\n\n    class RouteEditor extends Button {\n      constructor(parameters?: IRouteEditorParameters);\n\n      getRoute(): router.Route;\n    }\n\n    interface IRouteEditorParameters {\n      data?: {\n        image?: string;\n        title?: string;\n      };\n      options?: IBaseButtonParametersOptions;\n      state?: object;\n    }\n\n    class RoutePanel implements IControl, ICustomizable {\n      constructor(parameters?: IRoutePanelParameters);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      routePanel: IRoutePanel;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n    }\n\n    interface IRoutePanelParameters {\n      options?: {\n        autofocus?: boolean;\n        float?: 'none' | 'left' | 'right';\n        floatIndex?: number;\n        maxWidth?: string;\n        position?: {\n          bottom?: number | string;\n          left?: number | string;\n          right?: number | string;\n          top?: number | string;\n        };\n        showHeader?: boolean;\n        title?: string;\n        visible?: boolean;\n        [key: string]: any;\n      };\n      state?: {\n        fromEnabled?: boolean;\n        from?: string;\n        to?: string;\n        type?: string;\n        toEnabled?: boolean;\n      };\n    }\n\n    class RulerControl extends Button {\n      constructor(parameters?: IRulerControlParameters);\n    }\n\n    interface IRulerControlParameters {\n      data?: object;\n      options?: {\n        adjustMapMargin?: boolean;\n        position?: {\n          bottom?: number | string;\n          left?: number | string;\n          right?: number | string;\n          top?: number | string;\n        };\n        scaleLine?: boolean;\n        visible?: boolean;\n      };\n      state?: object;\n    }\n\n    class SearchControl implements IControl, ICustomizable {\n      constructor(parameters?: ISearchControlParameters);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      state: data.Manager;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n\n      clear(): void;\n\n      getMap(): Map;\n\n      getRequestString(): string;\n\n      getResponseMetaData(): object;\n\n      getResult(index: number): Promise<object>;\n\n      getResultsArray(): object[];\n\n      getResultsCount(): number;\n\n      getSelectedIndex(): number;\n\n      hideResult(): void;\n\n      search(request: string): Promise<void>;\n\n      showResult(index: number): this;\n    }\n\n    interface ISearchControlParameters {\n      data?: object;\n      options?: {\n        adjustMapMargin?: boolean;\n        boundedBy?: number[][];\n        fitMaxWidth?: boolean;\n        float?: 'none' | 'left' | 'right';\n        floatIndex?: number;\n        formLayout?: string | IClassConstructor<ILayout>;\n        kind?: 'house' | 'street' | 'metro' | 'district' | 'locality';\n        layout?: string | IClassConstructor<ISearchControlLayout>;\n        maxWidth?: number[][] | number[] | number;\n        noCentering?: boolean;\n        noPlacemark?: boolean;\n        noPopup?: boolean;\n        noSelect?: boolean;\n        noSuggestPanel?: boolean;\n        placeholderContent?: string;\n        popupItemLayout?: string | IClassConstructor<ILayout>;\n        popupLayout?: string | IClassConstructor<ILayout>;\n        position?: {\n          bottom?: number | string;\n          left?: number | string;\n          right?: number | string;\n          top?: number | string;\n        };\n        provider?: IGeocodeProvider | 'yandex#map' | 'yandex#search';\n        searchCoordOrder?: 'latlong' | 'longlat';\n        size?: 'auto' | 'small' | 'medium' | 'large';\n        strictBounds?: boolean;\n        suppressYandexSearch?: boolean;\n        useMapBounds?: boolean;\n        zoomMargin?: number;\n        visible?: boolean;\n      };\n      state?: object;\n    }\n\n    const storage: util.Storage;\n\n    class TrafficControl implements IControl, ICustomizable {\n      constructor(parameters?: ITrafficControlParameters);\n\n      data: data.Manager;\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      state: data.Manager;\n\n      collapse(): void;\n\n      expand(): void;\n\n      getMap(): Map;\n\n      getParent(): null | IControlParent;\n\n      getProvider(key: TrafficControlProviderKey): ITrafficProvider;\n\n      hideTraffic(): void;\n\n      isExpanded(): boolean;\n\n      isTrafficShown(): boolean;\n\n      setParent(parent: IControlParent): this;\n\n      showTraffic(): void;\n    }\n\n    type TrafficControlProviderKey = 'traffic#actual' | 'traffic#archive';\n\n    interface ITrafficProvider extends ICustomizable, IEventEmitter {\n      getMap(): Map | null;\n\n      setMap(map: Map): void;\n    }\n\n    interface ITrafficControlParameters {\n      options: {\n        adjustMapMargin?: boolean;\n        collapseOnBlur?: boolean;\n        float?: 'none' | 'left' | 'right';\n        floatIndex: number;\n        layout?: string | IClassConstructor<ISelectableControlLayout>;\n        maxWidth?: number | number[];\n        position?: {\n          bottom?: number | string;\n          left?: number | string;\n          right?: number | string;\n          top?: number | string;\n        };\n        size?: string;\n        visible?: boolean;\n        state?: {\n          providerKey?: TrafficControlProviderKey;\n          trafficShown?: boolean;\n        };\n      };\n    }\n\n    class TypeSelector extends ListBox {\n      constructor(parameters?: ITypeSelectorParameters);\n    }\n\n    interface ITypeSelectorParameters {\n      options?: {\n        panoramasItemMode: 'on' | 'off' | 'ifMercator';\n      };\n    }\n\n    class ZoomControl implements IControl, ICustomizable {\n      constructor(parameters?: IZoomControlParameters);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      state: data.Manager;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n\n      clear(): void;\n\n      getMap(): Map;\n\n      getRequestString(): string;\n\n      getResponseMetaData(): object;\n\n      getResult(index: number): Promise<object>;\n\n      getResultsArray(): object[];\n\n      getResultsCount(): number;\n\n      getSelectedIndex(): number;\n\n      hideResult(): void;\n\n      search(request: string): Promise<void>;\n\n      showResult(index: number): this;\n    }\n\n    interface IZoomControlParameters {\n      data?: object;\n      options?: {\n        adjustMapMargin?: boolean;\n        layout?: string | IClassConstructor<IZoomControlLayout>;\n        float?: 'none' | 'left' | 'right';\n        position?: {\n          bottom?: number | string;\n          left?: number | string;\n          right?: number | string;\n          top?: number | string;\n        };\n        size?: string;\n        visible?: boolean;\n        zoomDuration?: number;\n        zoomStep?: number;\n        state?: object;\n      };\n    }\n\n    type IZoomControlLayout = ILayout;\n  }\n\n  namespace data {\n    class Manager implements IDataManager, IFreezable {\n      constructor(data?: object);\n\n      events: IEventManager;\n\n      get(path: string, defaultValue?: object): object;\n\n      getAll(): object;\n\n      set(path: object | string, value?: object | number | string | null | undefined): this;\n\n      setAll(): this;\n\n      unset(path: object | string): this;\n\n      unsetAll(): this;\n\n      freeze(): IFreezable;\n\n      isFrozen(): boolean;\n\n      unfreeze(): IFreezable;\n\n      add(\n        types: string[][] | string[] | string,\n        callback: (event: object | IEvent) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n\n      getParent(): IEventManager | null;\n\n      group(): IEventGroup;\n\n      remove(\n        types: string[][] | string[] | string,\n        callback: (event: object | IEvent) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n\n      setParent(parent: IEventManager | null): this;\n\n      fire(type: string, eventObject: object | IEvent): this;\n    }\n  }\n\n  namespace domEvent {\n    interface manager {\n      add<K extends keyof EventMap>(\n        htmlElement: HTMLElement | Document,\n        types: K,\n        callback: (event: EventMap[K]) => void,\n        context?: object,\n        capture?: boolean,\n      ): this;\n\n      add(\n        htmlElement: HTMLElement | Document,\n        types: string[] | string,\n        callback: (event: any) => void,\n        context?: object,\n        capture?: boolean,\n      ): this;\n\n      group(htmlElement: HTMLElement | Document, capture?: boolean): event.Group;\n\n      remove(\n        htmlElement: HTMLElement | Document,\n        types: string[] | string,\n        callback: ((event: any) => void) | string,\n        context?: object,\n        capture?: boolean,\n      ): this;\n    }\n  }\n\n  namespace event {\n    class Group implements IEventGroup {\n      events: IEventManager;\n\n      add<K extends keyof EventMap>(\n        types: K,\n        callback: (event: EventMap[K] | IEvent) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n      add(\n        types: string[][] | string[] | string,\n        callback: (event: object | IEvent) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n\n      remove(\n        types: string[][] | string[] | string,\n        callback: (event: object | IEvent) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n\n      removeAll(): this;\n\n      getLength(): number;\n    }\n\n    class Manager<TargetGeometry = {}> implements IEventManager<TargetGeometry> {\n      constructor(params?: {\n        context?: object | undefined;\n        controllers?: IEventWorkflowController[] | undefined;\n        parent?: IEventManager | undefined;\n      });\n\n      add<K extends keyof EventMap>(\n        types: K,\n        callback: (event: IEvent<EventMap[K], TargetGeometry>) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n\n      add(\n        types: string[][] | string[] | string,\n        callback: (event: IEvent<{}, TargetGeometry>) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n\n      getParent(): IEventManager | null;\n\n      group(): IEventGroup;\n\n      remove(\n        types: string[][] | string[] | string,\n        callback: (event: object | IEvent) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n\n      setParent(parent: IEventManager | null): this;\n\n      fire(type: string, eventObject: object | IEvent): this;\n\n      createEventObject(type: string, event: object, target: object): Event;\n\n      once(\n        types: string[][] | string[] | string,\n        callback: (event: IEvent) => any,\n        context?: object,\n        priority?: number,\n      ): this;\n    }\n\n    class Mapper implements IEventTrigger {\n      constructor(\n        targetEventManager: IEventManager,\n        mappingTable: Record<string, ((event: IEvent) => IEvent | null) | boolean>,\n      );\n\n      fire(type: string, eventObject?: object | IEvent): this;\n    }\n  }\n\n  namespace geometry {\n    namespace base {\n      class LineString implements IBaseLineStringGeometry {\n        events: IEventManager;\n\n        static fromEncodedCoordinates(encodedCoordinates: string): geometry.LineString;\n\n        static toEncodedCoordinates(geometry: geometry.LineString): string;\n\n        getBounds(): number[][] | null;\n\n        getType(): string;\n\n        get(index: number): number[];\n\n        getChildGeometry(index: number): IPointGeometryAccess;\n\n        getClosest(anchorPosition: number[]): object;\n\n        getCoordinates(): number[][];\n\n        getLength(): number;\n\n        insert(index: number, coordinates: number[][]): ILineStringGeometryAccess;\n\n        remove(index: number): number[];\n\n        remove(\n          types: string[][] | string[] | string,\n          callback: (event: object | IEvent) => void,\n          context?: object,\n          priority?: number,\n        ): this;\n\n        set(index: number, coordinates: number[]): ILineStringGeometryAccess;\n\n        setCoordinates(coordinates: number[][]): ILineStringGeometryAccess;\n\n        splice(index: number, length: number): number[][];\n\n        freeze(): IFreezable;\n\n        isFrozen(): boolean;\n\n        unfreeze(): IFreezable;\n\n        add(\n          types: string[][] | string[] | string,\n          callback: (event: object | IEvent) => void,\n          context?: object,\n          priority?: number,\n        ): this;\n\n        getParent(): object | null;\n\n        group(): IEventGroup;\n\n        setParent(parent: IEventManager | null): this;\n\n        fire(type: string, eventObject: object | IEvent): this;\n      }\n\n      class Point implements IBasePointGeometry {\n        events: IEventManager;\n\n        getBounds(): number[][] | null;\n\n        getType(): string;\n\n        getCoordinates(): number[] | null;\n\n        setCoordinates(coordinates: number[] | null): this;\n      }\n\n      class Polygon implements IBasePointGeometry {\n        constructor(coordinates?: number[][][], fillRule?: 'evenOdd' | 'nonZero');\n\n        events: IEventManager;\n\n        static fromEncodedCoordinates(encodedCoordinates: string): Polygon;\n\n        static toEncodedCoordinates(geometry: Polygon): string;\n\n        contains(position: number[]): boolean;\n\n        freeze(): IFreezable;\n\n        get(index: number): number[][];\n\n        getBounds(): number[][] | null;\n\n        getChildGeometry(index: number): ILinearRingGeometryAccess;\n\n        getClosest(anchorPosition: number[]): object;\n\n        getCoordinates(): number[] | null;\n\n        getFillRule(): 'evenOdd' | 'nonZero';\n\n        getLength(): number;\n\n        getType(): string;\n\n        insert(index: number, path: number[][]): IPolygonGeometryAccess;\n\n        isFrozen(): boolean;\n\n        remove(index: number): ILinearRingGeometryAccess;\n\n        set(index: number, path: number[][]): IPolygonGeometryAccess;\n\n        setCoordinates(coordinates: number[] | null): this;\n\n        setFillRule(fillRule: 'evenOdd' | 'nonZero'): IPolygonGeometryAccess;\n\n        splice(index: number, number: number): ILinearRingGeometryAccess[];\n\n        unfreeze(): IFreezable;\n      }\n    }\n\n    class Circle implements ICircleGeometry {\n      constructor(\n        coordinates?: number[] | null,\n        radius?: number,\n        options?: {\n          geodesic?: boolean;\n          pixelRendering?: string;\n          projection?: IProjection;\n        },\n      );\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      contains(position: number[]): boolean;\n\n      freeze(): IFreezable;\n\n      getBounds(): number[][] | null;\n\n      getClosest(anchorPosition: number[]): object;\n\n      getCoordinates(): number[] | null;\n\n      getMap(): Map | null;\n\n      getPixelGeometry(options?: object): IPixelGeometry;\n\n      getRadius(): number;\n\n      getType(): string;\n\n      isFrozen(): boolean;\n\n      setCoordinates(coordinates: number[] | null): ICircleGeometryAccess;\n\n      setMap(map: Map): void;\n\n      setRadius(radius: number): ICircleGeometryAccess;\n\n      unfreeze(): IFreezable;\n    }\n\n    class LineString implements ILineStringGeometry {\n      constructor(\n        coordinates?: number[][],\n        options?: {\n          coordRendering?: 'shortestPath' | 'straightPath';\n          geodesic?: boolean;\n          pixelRendering?: 'jumpy' | 'static';\n          projection?: IProjection;\n          simplification?: boolean;\n        },\n      );\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      static fromEncodedCoordinates(encodedCoordinates: string): LineString;\n\n      static toEncodedCoordinates(geometry: LineString): string;\n\n      getMap(): Map | null;\n\n      getPixelGeometry(options?: object): IPixelGeometry;\n\n      setMap(map: Map): void;\n\n      getBounds(): number[][] | null;\n\n      getType(): string;\n\n      get(index: number): number[];\n\n      getChildGeometry(index: number): IPointGeometryAccess;\n\n      getClosest(anchorPosition: number[]): object;\n\n      getCoordinates(): number[][];\n\n      getLength(): number;\n\n      insert(index: number, coordinates: number[][]): ILineStringGeometryAccess;\n\n      remove(index: number): number[];\n\n      remove(\n        types: string[][] | string[] | string,\n        callback: (event: object | IEvent) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n\n      set(index: number, coordinates: number[]): ILineStringGeometryAccess;\n\n      setCoordinates(coordinates: number[][]): ILineStringGeometryAccess;\n\n      splice(index: number, length: number): number[][];\n\n      freeze(): IFreezable;\n\n      isFrozen(): boolean;\n\n      unfreeze(): IFreezable;\n\n      add(\n        types: string[][] | string[] | string,\n        callback: (event: object | IEvent) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n\n      getParent(): object | null;\n\n      group(): IEventGroup;\n\n      setParent(parent: IEventManager | null): this;\n\n      fire(type: string, eventObject: object | IEvent): this;\n    }\n\n    namespace pixel {\n      class Circle implements IPixelCircleGeometry {\n        constructor(coordinates: number[] | null, radius: number, metaData?: object);\n\n        events: IEventManager;\n\n        equals(geometry: IPixelGeometry): boolean;\n\n        getBounds(): number[][] | null;\n\n        getCoordinates(): number[];\n\n        getMetaData(): object;\n\n        getRadius(): number;\n\n        getType(): string;\n\n        scale(factor: number): IPixelGeometry;\n\n        shift(offset: number[]): IPixelGeometry;\n      }\n\n      class LineString implements IPixelLineStringGeometry {\n        constructor(coordinates: number[][], metaData?: object);\n\n        events: IEventManager;\n\n        equals(geometry: IPixelGeometry): boolean;\n\n        getBounds(): number[][] | null;\n\n        getClosest(anchorPosition: number[]): object;\n\n        getCoordinates(): number[][];\n\n        getLength(): number;\n\n        getMetaData(): object;\n\n        getType(): string;\n\n        scale(factor: number): IPixelGeometry;\n\n        shift(offset: number[]): IPixelGeometry;\n      }\n\n      class MultiLineString implements IPixelMultiLineGeometry {\n        constructor(coordinates: number[][][], metaData?: object);\n\n        events: IEventManager;\n\n        equals(geometry: IPixelGeometry): boolean;\n\n        getBounds(): number[][] | null;\n\n        getClosest(anchorPosition: number[]): object;\n\n        getCoordinates(): number[][][];\n\n        getLength(): number;\n\n        getMetaData(): object;\n\n        getType(): string;\n\n        scale(factor: number): IPixelGeometry;\n\n        shift(offset: number[]): IPixelGeometry;\n      }\n\n      class MultiPolygon implements IPixelMultiPolygonGeometry {\n        constructor(\n          coordinates: number[][][][],\n          fillRule: 'evenOdd' | 'nonZero',\n          metaData?: object,\n        );\n\n        events: IEventManager;\n\n        contains(position: number[]): boolean;\n\n        equals(geometry: IPixelGeometry): boolean;\n\n        getBounds(): number[][] | null;\n\n        getClosest(anchorPosition: number[]): object;\n\n        getCoordinates(): number[][][][];\n\n        getFillRule(): 'evenOdd' | 'nonZero';\n\n        getLength(): number;\n\n        getMetaData(): object;\n\n        getType(): string;\n\n        scale(factor: number): IPixelGeometry;\n\n        shift(offset: number[]): IPixelGeometry;\n      }\n\n      class Point implements IPixelPointGeometry {\n        constructor(position: number[] | null, metaData?: object);\n\n        events: IEventManager;\n\n        equals(geometry: IPixelGeometry): boolean;\n\n        getBounds(): number[][] | null;\n\n        getCoordinates(): number[];\n\n        getMetaData(): object;\n\n        getType(): string;\n\n        scale(factor: number): IPixelGeometry;\n\n        shift(offset: number[]): IPixelGeometry;\n      }\n\n      class Polygon implements IPixelPolygonGeometry {\n        constructor(coordinates: number[][][], fillRule: 'evenOdd' | 'nonZero', metaData?: object);\n\n        events: IEventManager;\n\n        contains(position: number[]): boolean;\n\n        equals(geometry: IPixelGeometry): boolean;\n\n        getBounds(): number[][] | null;\n\n        getClosest(anchorPosition: number[]): object;\n\n        getCoordinates(): number[][][];\n\n        getFillRule(): 'evenOdd' | 'nonZero';\n\n        getLength(): number;\n\n        getMetaData(): object;\n\n        getType(): string;\n\n        scale(factor: number): IPixelGeometry;\n\n        shift(offset: number[]): IPixelGeometry;\n      }\n\n      class Rectangle implements IPixelRectangleGeometry {\n        constructor(coordinates: number[][] | null, metaData?: object);\n\n        events: IEventManager;\n\n        equals(geometry: IPixelGeometry): boolean;\n\n        getBounds(): number[][] | null;\n\n        getClosest(anchorPosition: number[]): object;\n\n        getCoordinates(): number[][];\n\n        getMetaData(): object;\n\n        getType(): string;\n\n        scale(factor: number): IPixelGeometry;\n\n        shift(offset: number[]): IPixelGeometry;\n      }\n    }\n\n    class Point implements IPointGeometry {\n      constructor(coordinates?: number[] | null);\n\n      options: IOptionManager;\n\n      events: IEventManager;\n\n      getMap(): Map | null;\n\n      getPixelGeometry(options?: object): IPixelGeometry;\n\n      setMap(map: Map): void;\n\n      getBounds(): number[][] | null;\n\n      getType(): string;\n\n      getCoordinates(): number[] | null;\n\n      setCoordinates(coordinates: number[] | null): this;\n    }\n\n    class Polygon implements IPolygonGeometry {\n      constructor(coordinates?: number[][][], fillRule?: 'evenOdd' | 'nonZero', options?: object);\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      static fromEncodedCoordinates(encodedCoordinates: string): Polygon;\n\n      static toEncodedCoordinates(geometry: Polygon): string;\n\n      add(\n        types: string[][] | string[] | string,\n        callback: (event: object | IEvent) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n\n      contains(position: number[]): boolean;\n\n      fire(type: string, eventObject: object | IEvent): this;\n\n      freeze(): IFreezable;\n\n      get(index: number): number[][];\n\n      getBounds(): number[][] | null;\n\n      getChildGeometry(index: number): ILinearRingGeometryAccess;\n\n      getClosest(anchorPosition: number[]): object;\n\n      getCoordinates(): number[][][];\n\n      getFillRule(): 'evenOdd' | 'nonZero';\n\n      getLength(): number;\n\n      getMap(): Map | null;\n\n      getParent(): object | null;\n\n      getPixelGeometry(options?: object): IPixelGeometry;\n\n      getType(): string;\n\n      group(): IEventGroup;\n\n      insert(index: number, path: number[][]): IPolygonGeometryAccess;\n\n      isFrozen(): boolean;\n\n      remove(index: number): ILinearRingGeometryAccess;\n\n      set(index: number, path: number[][]): IPolygonGeometryAccess;\n\n      setCoordinates(coordinates: number[][][]): IPolygonGeometryAccess;\n\n      setFillRule(fillRule: 'evenOdd' | 'nonZero'): IPolygonGeometryAccess;\n\n      setMap(map: Map): void;\n\n      setParent(parent: object | null): this;\n\n      splice(index: number, number: number): ILinearRingGeometryAccess[];\n\n      unfreeze(): IFreezable;\n    }\n\n    class Rectangle implements IRectangleGeometry {\n      constructor(\n        coordinates?: number[][] | null,\n        options?: {\n          coordRendering?: string;\n          geodesic?: boolean;\n          pixelRendering?: string;\n          projection?: IProjection;\n        },\n      );\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      contains(position: number[]): boolean;\n\n      freeze(): IFreezable;\n\n      getBounds(): number[][] | null;\n\n      getClosest(anchorPosition: number[]): object;\n\n      getCoordinates(): number[][];\n\n      getMap(): Map | null;\n\n      getPixelGeometry(options?: object): IPixelGeometry;\n\n      getType(): string;\n\n      isFrozen(): boolean;\n\n      setCoordinates(coordinates: number[][]): IRectangleGeometryAccess;\n\n      setMap(map: Map): void;\n\n      unfreeze(): IFreezable;\n    }\n  }\n\n  namespace geometryEditor {\n    class Circle implements IGeometryEditor {\n      constructor(geometry: ICircleGeometry, options?: object);\n\n      events: IEventManager;\n\n      geometry: IGeometry;\n\n      options: IOptionManager;\n\n      state: IDataManager;\n\n      startDrawing(): vow.Promise;\n\n      startEditing(): void;\n\n      stopDrawing(): vow.Promise;\n\n      stopEditing(): void;\n    }\n\n    class LineString implements IGeometryEditor {\n      constructor(geometry: ILineStringGeometry, options?: object);\n\n      events: IEventManager;\n\n      geometry: IGeometry;\n\n      options: IOptionManager;\n\n      state: IDataManager;\n\n      getModel(): vow.Promise;\n\n      getModelSync(): model.RootLineString | null;\n\n      getView(): vow.Promise;\n\n      getViewSync(): view.Path | null;\n\n      startDrawing(): vow.Promise;\n\n      startEditing(): vow.Promise;\n\n      startFraming(): vow.Promise;\n\n      stopDrawing(): void;\n\n      stopEditing(): void;\n\n      stopFraming(): void;\n    }\n\n    namespace model {\n      class ChildLinearRing extends ChildLineString {}\n\n      class ChildLineString implements IGeometryEditorChildModel {\n        editor: IGeometryEditor;\n\n        events: IEventManager;\n\n        geometry: IBaseGeometry;\n\n        destroy(): void;\n\n        getAllVerticesNumber(): number;\n\n        getEdgeModels(): Edge[];\n\n        getIndex(): number;\n\n        getParent(): IGeometryEditorModel;\n\n        getPixels(): number[];\n\n        getVertexModels(): ChildVertex[];\n\n        setIndex(index: number): void;\n\n        setPixels(pixels: number[]): void;\n\n        spliceVertices(start: number, deleteCount: number): number[][];\n      }\n\n      class ChildVertex implements IGeometryEditorChildModel {\n        editor: IGeometryEditor;\n\n        events: IEventManager;\n\n        geometry: IBaseGeometry;\n\n        destroy(): void;\n\n        getAllVerticesNumber(): number;\n\n        getIndex(): number;\n\n        getNextVertex(): ChildVertex | null;\n\n        getParent(): IGeometryEditorModel;\n\n        getPixels(): number[];\n\n        getPrevVertex(): ChildVertex | null;\n\n        setGlobalPixels(pixels: number[]): void;\n\n        setIndex(index: number): void;\n\n        setNextVertex(nextVertex: ChildVertex): void;\n\n        setPixels(pixels: number[]): void;\n\n        setPrevVertex(prevVertex: ChildVertex): void;\n      }\n\n      class Edge implements IGeometryEditorRootModel {\n        events: IEventManager;\n\n        destroy(): void;\n\n        getNextVertex(): ChildVertex | null;\n\n        getPixels(): number[];\n\n        getPrevVertex(): ChildVertex | null;\n\n        setNextVertex(nextVertex: ChildVertex): void;\n\n        setPrevVertex(prevVertex: ChildVertex): void;\n      }\n\n      class EdgeGeometry implements IGeometry {\n        events: IEventManager;\n\n        options: IOptionManager;\n\n        getBounds(): number[][] | null;\n\n        getMap(): Map | null;\n\n        getPixelGeometry(options?: object): IPixelGeometry;\n\n        getType(): string;\n\n        setMap(map: Map): void;\n      }\n\n      class RootLineString implements IGeometryEditorRootModel {\n        events: IEventManager;\n\n        destroy(): void;\n\n        getAllVerticesNumber(): number;\n\n        getPixels(): number[];\n\n        getVertexModels(): ChildVertex[];\n\n        spliceVertices(start: number, deleteCount: number): number[][];\n      }\n\n      class RootPolygon implements IGeometryEditorRootModel {\n        events: IEventManager;\n\n        destroy(): void;\n\n        getAllVerticesNumber(): number;\n\n        getPathModels(): ChildLinearRing[];\n\n        getPixels(): number[];\n\n        splicePaths(start: number, deleteCount: number): number[][];\n      }\n    }\n\n    class Point implements IGeometryEditor {\n      constructor(\n        geometry: IPointGeometry,\n        options?: {\n          dblClickHandler?: (ref: any) => void;\n          drawingCursor?: string;\n          drawOver?: boolean;\n        },\n      );\n\n      events: IEventManager;\n\n      geometry: IGeometry;\n\n      options: IOptionManager;\n\n      state: IDataManager;\n\n      startDrawing(): vow.Promise;\n\n      startEditing(): void;\n\n      stopDrawing(): vow.Promise;\n\n      stopEditing(): void;\n    }\n\n    class Polygon implements IGeometryEditor {\n      constructor(geometry: IPolygonGeometry, options: object);\n\n      events: IEventManager;\n\n      geometry: IGeometry;\n\n      options: IOptionManager;\n\n      state: IDataManager;\n\n      getModel(): vow.Promise;\n\n      getModelSync(): model.RootPolygon | null;\n\n      getView(): vow.Promise;\n\n      getViewSync(): view.MultiPath | null;\n\n      startDrawing(): vow.Promise;\n\n      startEditing(): vow.Promise;\n\n      startFraming(): vow.Promise;\n\n      stopDrawing(): void;\n\n      stopEditing(): void;\n\n      stopFraming(): void;\n    }\n\n    namespace view {\n      class Edge {\n        getPlacemark(): GeoObject;\n      }\n\n      class MultiPath {\n        getEdgePlacemarks(): GeoObjectCollection;\n\n        getPathViews(): Path[];\n\n        getVertexPlacemarks(): GeoObjectCollection;\n      }\n\n      class Path {\n        getEdgePlacemarks(): GeoObjectCollection;\n\n        getEdgeViews(): Edge[];\n\n        getVertexPlacemarks(): GeoObjectCollection;\n\n        getVertexViews(): Vertex[];\n      }\n\n      class Vertex {\n        getPlacemark(): GeoObject;\n      }\n    }\n  }\n\n  namespace geoObject {\n    class Balloon implements IBalloonManager<GeoObject> {\n      constructor(geoObject: GeoObject);\n\n      events: IEventManager;\n\n      autoPan(): Promise<GeoObject>;\n\n      close(force?: boolean): Promise<GeoObject>;\n\n      destroy(): void;\n\n      getData(): object | null;\n\n      getOptions(): IOptionManager | null;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getPosition(): number[] | null;\n\n      isOpen(): boolean;\n\n      open(\n        position?: number[],\n        data?: object | string | HTMLElement,\n        options?: object,\n      ): Promise<GeoObject>;\n\n      setData(data: object | string | HTMLElement): Promise<GeoObject>;\n\n      setOptions(options: object): Promise<GeoObject>;\n\n      setPosition(position: number[]): Promise<GeoObject>;\n    }\n\n    class Hint implements IHintManager<GeoObject> {\n      constructor(geoObject: GeoObject);\n\n      events: IEventManager;\n\n      close(force?: boolean): Promise<GeoObject>;\n\n      destroy(): void;\n\n      getData(): object | null;\n\n      getOptions(): IOptionManager | null;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getPosition(): number[] | null;\n\n      isOpen(): boolean;\n\n      open(\n        position?: number[],\n        data?: object | string | HTMLElement,\n        options?: object,\n      ): Promise<GeoObject>;\n\n      setData(data: object | string | HTMLElement): Promise<GeoObject>;\n\n      setOptions(options: object): Promise<GeoObject>;\n\n      setPosition(position: number[]): Promise<GeoObject>;\n    }\n\n    class Sequence implements IGeoObject, IGeoObjectSequence {\n      constructor(geoObject: GeoObject);\n\n      geometry: IGeometry | null;\n\n      properties: IDataManager;\n\n      state: IDataManager;\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n\n      getMap(): Map;\n\n      each(callback: (geoObject: IGeoObject) => void, context?: object): void;\n\n      get(index: number): IGeoObject;\n\n      getBounds(): number[][] | null;\n\n      getIterator(): IIterator;\n\n      getLength(): number;\n\n      getPixelBounds(): number[][] | null;\n\n      indexOf(geoObject: IGeoObject): number;\n    }\n  }\n\n  namespace layout {\n    namespace templateBased {\n      class Base implements ILayout {\n        constructor(data: object);\n\n        events: IEventManager;\n\n        destroy(): void;\n\n        getData(): object;\n\n        getParentElement(): HTMLElement;\n\n        getShape(): IShape | null;\n\n        isEmpty(): boolean;\n\n        setData(data: object): void;\n\n        setParentElement(parent: HTMLElement | null): this;\n\n        build(): void;\n\n        clear(): void;\n\n        onSublayoutSizeChange(sublayoutInfo: object, nodeSizeByContent: object): void;\n\n        rebuild(): void;\n      }\n    }\n\n    interface IImageOptions {\n      imageClipRect?: number[][] | undefined;\n      imageHref?: string | undefined;\n      imageOffset?: number[] | undefined;\n      imageSize?: number[] | undefined;\n      shape?: IShape | object | null | undefined;\n    }\n\n    interface IImageOptionsWithIconPrefix {\n      iconImageClipRect?: number[][] | undefined;\n      iconImageHref?: string | undefined;\n      iconImageOffset?: number[] | undefined;\n      iconImageSize?: number[] | undefined;\n      iconShape?: IShape | object | null | undefined;\n    }\n\n    class Image implements ILayout {\n      constructor(data: { options?: IImageOptions });\n\n      events: IEventManager;\n\n      destroy(): void;\n\n      getData(): object;\n\n      getParentElement(): HTMLElement;\n\n      getShape(): IShape | null;\n\n      isEmpty(): boolean;\n\n      setData(data: object): void;\n\n      setParentElement(parent: HTMLElement | null): void;\n    }\n\n    class ImageWithContent extends Image {}\n\n    interface IImageWithContentOptionsWithIconPrefix extends IImageOptionsWithIconPrefix {\n      iconContentLayout?: IClassConstructor<ILayout> | string | undefined;\n      iconContentOffset?: number[] | undefined;\n      iconContentSize?: number[] | undefined;\n    }\n\n    class PieChart extends templateBased.Base {}\n\n    interface IPieChartOptionsWithIconPrefix {\n      iconPieChartCaptionMaxWidth?: number | undefined;\n      iconPieChartCoreFillStyle?: string | undefined;\n      iconPieChartCoreRadius?: number | (() => number) | undefined;\n      iconPieChartStrokeStyle?: string | undefined;\n      iconPieChartStrokeWidth?: number | undefined;\n    }\n\n    const storage: util.Storage;\n  }\n\n  namespace map {\n    namespace action {\n      class Manager implements IEventEmitter {\n        constructor(map: Map);\n\n        events: IEventManager;\n\n        breakTick(): void;\n\n        execute(action: IMapAction): void;\n\n        getCurrentState(): object;\n\n        getMap(): Map;\n\n        setCorrection(userFunction: () => void): void;\n\n        stop(): void;\n      }\n    }\n\n    namespace behavior {\n      class Manager implements ICustomizable, IEventEmitter, IParentOnMap {\n        constructor(map: Map, behaviors?: string[][] | string[], options?: object);\n\n        options: IOptionManager;\n\n        events: IEventManager;\n\n        getMap(): Map;\n\n        disable(behaviors: string[][] | string[] | string): this;\n\n        enable(behaviors: string[][] | string[] | string): this;\n\n        get(behaviorName: string): IBehavior;\n\n        isEnabled(behaviorName: string): boolean;\n      }\n    }\n\n    namespace layer {\n      class Manager implements ILayer, IMapObjectCollection {\n        constructor(\n          map: Map,\n          options?: {\n            trafficImageZIndex?: number;\n            trafficInfoZIndex?: number;\n            trafficJamZIndex?: number;\n          },\n        );\n\n        events: IEventManager;\n\n        options: IOptionManager;\n\n        getParent(): null | IControlParent;\n\n        setParent(parent: IControlParent): this;\n\n        add(object: object): this;\n\n        each(callback: (layer: ILayer) => void, context?: object): void;\n\n        getIterator(): IIterator;\n\n        remove(object: object): this;\n\n        getMap(): Map;\n\n        getAll(): Array<Collection<Layer>>;\n      }\n    }\n\n    namespace margin {\n      class Accessor {\n        constructor(screenArea: object);\n\n        getArea(): object;\n\n        remove(): this;\n\n        setArea(screenArea: object): this;\n      }\n\n      class Manager {\n        constructor(map: Map);\n\n        addArea(screenArea: object): Accessor;\n\n        destroy(): this;\n\n        getMargin(): number[];\n\n        getOffset(): number[];\n\n        setDefaultMargin(margin: number[][] | number[] | number): void;\n      }\n    }\n\n    namespace pane {\n      class Manager {\n        constructor(map: Map);\n\n        append(key: string, pane: IPane): void;\n\n        destroy(): void;\n\n        get(key: string): IPane | null;\n\n        getLower(): string;\n\n        getUpper(): string;\n\n        insertBefore(key: string, pane: IPane, referenceKey: string): void;\n\n        remove(pane: IPane): void;\n      }\n    }\n\n    class Balloon implements IBalloonManager<Balloon> /* , IBalloonSharingManager */ {\n      constructor(map: Map);\n\n      events: IEventManager;\n\n      autoPan(): Promise<Balloon>;\n\n      close(force?: boolean): Promise<Balloon>;\n\n      destroy(): void;\n\n      getData(): object | null;\n\n      getOptions(): IOptionManager | null;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getPosition(): number[] | null;\n\n      isOpen(): boolean;\n\n      open(\n        position?: number[],\n        data?: object | string | HTMLElement,\n        options?: object,\n      ): Promise<Balloon>;\n\n      setData(data: object | string | HTMLElement): Promise<Balloon>;\n\n      setOptions(options: object): Promise<Balloon>;\n\n      setPosition(position: number[]): Promise<Balloon>;\n    }\n\n    class Container implements IDomEventEmitter {\n      constructor(parentElement: string | HTMLElement);\n\n      events: IEventManager;\n\n      enterFullscreen(): void;\n\n      exitFullscreen(): void;\n\n      fitToViewport(preservePixelPosition?: boolean): void;\n\n      getElement(): HTMLElement;\n\n      getOffset(): number[];\n\n      getParentElement(): HTMLElement;\n\n      getSize(): number[];\n\n      isFullscreen(): boolean;\n    }\n\n    class Converter {\n      constructor(map: Map);\n\n      globalToPage(globalPixelPoint: number[]): number[];\n\n      pageToGlobal(pagePixelPoint: number[]): number[];\n    }\n\n    class Copyrights {\n      constructor(map: Map);\n\n      add(\n        customCopyrights: string | HTMLElement | Array<string | HTMLElement>,\n      ): ICopyrightsAccessor;\n\n      addProvider(provider: ICopyrightsProvider): this;\n\n      get(point?: number[], zoom?: number): Promise<Array<string | HTMLElement>>;\n\n      getPromoLink(): string;\n\n      removeProvider(provider: ICopyrightsProvider): this;\n    }\n\n    class GeoObjects implements IGeoObjectCollection {\n      constructor(map: Map, options?: object);\n\n      options: IOptionManager;\n\n      events: IEventManager;\n\n      add(child: IGeoObject | ObjectManager | Clusterer, index?: number): this;\n\n      each(callback: (object: IGeoObject) => void, context?: object): void;\n\n      get(index: number): IGeoObject;\n\n      getBounds(): number[][] | null;\n\n      getIterator(): IIterator;\n\n      getLength(): number;\n\n      getPixelBounds(): number[][] | null;\n\n      indexOf(object: IGeoObject): number;\n\n      remove(child: IGeoObject | ObjectManager): this;\n\n      removeAll(): this;\n\n      set(index: number, child: IGeoObject): this;\n\n      splice(index: number, length: number): this;\n\n      getMap(): Map;\n    }\n\n    class Hint implements IHintManager<Hint> /* , IHintSharingManager */ {\n      constructor(map: Map);\n\n      events: IEventManager;\n\n      close(force?: boolean): Promise<Hint>;\n\n      destroy(): void;\n\n      getData(): object | null;\n\n      getOptions(): IOptionManager | null;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getPosition(): number[] | null;\n\n      isOpen(): boolean;\n\n      open(\n        position?: number[],\n        data?: object | string | HTMLElement,\n        options?: object,\n      ): Promise<Hint>;\n\n      setData(data: object | string | HTMLElement): Promise<Hint>;\n\n      setOptions(options: object): Promise<Hint>;\n\n      setPosition(position: number[]): Promise<Hint>;\n    }\n\n    class ZoomRange implements IEventEmitter {\n      constructor(map: Map, constraints: number[]);\n\n      events: IEventManager;\n\n      get(coords?: number[]): Promise<number[]>;\n\n      getCurrent(): number[];\n    }\n  }\n\n  namespace multiRouter {\n    namespace driving {\n      class Path implements IGeoObject {\n        geometry: IGeometry | null;\n\n        properties: data.Manager;\n\n        state: IDataManager;\n\n        model: PathModel;\n\n        events: IEventManager;\n\n        options: IOptionManager;\n\n        getOverlay(): Promise<IOverlay | null>;\n\n        getOverlaySync(): IOverlay | null;\n\n        getParent(): object | null;\n\n        setParent(parent: object): this;\n\n        getMap(): Map;\n\n        getSegments(): GeoObjectCollection;\n      }\n\n      class PathModel implements IEventEmitter {\n        events: IEventManager;\n\n        properties: data.Manager;\n\n        route: RouteModel;\n\n        destroy(): void;\n\n        getSegments(): SegmentModel[];\n\n        getType(): string;\n\n        update(pathJson: object): void;\n      }\n\n      class Route implements IGeoObject {\n        geometry: IGeometry | null;\n\n        properties: IDataManager;\n\n        state: IDataManager;\n\n        events: IEventManager;\n\n        options: IOptionManager;\n\n        balloon: geoObject.Balloon;\n\n        getOverlay(): Promise<IOverlay | null>;\n\n        getOverlaySync(): IOverlay | null;\n\n        getParent(): object | null;\n\n        setParent(parent: object): this;\n\n        getMap(): Map;\n\n        getPaths(): GeoObjectCollection;\n      }\n\n      class RouteModel implements IEventEmitter {\n        events: IEventManager;\n\n        multiRoute: MultiRouteModel;\n\n        properties: data.Manager;\n\n        destroy(): void;\n\n        getPaths(): PathModel[];\n\n        update(routeJson: object): void;\n\n        getType(): string;\n      }\n\n      class Segment implements IGeoObject {\n        geometry: IGeometry | null;\n\n        properties: data.Manager;\n\n        state: IDataManager;\n\n        events: IEventManager;\n\n        options: IOptionManager;\n\n        getOverlay(): Promise<IOverlay | null>;\n\n        getOverlaySync(): IOverlay | null;\n\n        getParent(): object | null;\n\n        setParent(parent: object): this;\n\n        getMap(): Map;\n      }\n\n      class SegmentModel implements IEventEmitter {\n        events: IEventManager;\n\n        geometry: geometry.base.LineString;\n\n        path: PathModel;\n\n        destroy(): void;\n\n        getType(): string;\n\n        getViaPoints(): ViaPointModel[];\n\n        update(segmentJson: object): void;\n      }\n    }\n\n    namespace masstransit {\n      class Path implements IGeoObject {\n        geometry: IGeometry | null;\n\n        properties: data.Manager;\n\n        state: IDataManager;\n\n        events: IEventManager;\n\n        options: IOptionManager;\n\n        model: PathModel;\n\n        getOverlay(): Promise<IOverlay | null>;\n\n        getOverlaySync(): IOverlay | null;\n\n        getParent(): object | null;\n\n        setParent(parent: object): this;\n\n        getMap(): Map;\n\n        getSegmentMarkers(): GeoObjectCollection;\n\n        getSegments(): GeoObjectCollection;\n      }\n\n      class PathModel implements IEventEmitter {\n        events: IEventManager;\n\n        properties: data.Manager;\n\n        route: RouteModel;\n\n        destroy(): void;\n\n        getSegments(): Array<TransferSegmentModel | TransportSegmentModel | WalkSegmentModel>;\n\n        getType(): string;\n\n        update(pathJson: object): void;\n      }\n\n      class Route implements IGeoObject {\n        geometry: IGeometry | null;\n\n        properties: data.Manager;\n\n        model: RouteModel;\n\n        state: IDataManager;\n\n        events: IEventManager;\n\n        options: IOptionManager;\n\n        balloon: geoObject.Balloon;\n\n        getOverlay(): Promise<IOverlay | null>;\n\n        getOverlaySync(): IOverlay | null;\n\n        getParent(): object | null;\n\n        setParent(parent: object): this;\n\n        getMap(): Map;\n\n        getPaths(): GeoObjectCollection;\n      }\n\n      class RouteModel implements IEventEmitter {\n        events: IEventManager;\n\n        multiRoute: MultiRouteModel;\n\n        properties: data.Manager;\n\n        destroy(): void;\n\n        getPaths(): PathModel[];\n\n        getType(): string;\n\n        update(routeJson: object): void;\n      }\n\n      class StopModel implements IEventEmitter {\n        events: IEventManager;\n\n        geometry: geometry.base.Point;\n\n        properties: data.Manager;\n\n        segment: TransportSegmentModel;\n\n        update(stopJson: object): void;\n      }\n\n      class TransferSegment implements IGeoObject {\n        geometry: IGeometry | null;\n\n        properties: data.Manager;\n\n        state: IDataManager;\n\n        events: IEventManager;\n\n        options: IOptionManager;\n\n        model: TransferSegmentModel;\n\n        getOverlay(): Promise<IOverlay | null>;\n\n        getOverlaySync(): IOverlay | null;\n\n        getParent(): object | null;\n\n        setParent(parent: object): this;\n\n        getMap(): Map;\n      }\n\n      class TransferSegmentModel implements IEventEmitter {\n        events: IEventManager;\n\n        geometry: geometry.base.LineString;\n\n        path: PathModel;\n\n        properties: data.Manager;\n\n        destroy(segmentJson: object): void;\n\n        getType(): string;\n      }\n\n      class TransportSegment implements IGeoObject {\n        geometry: IGeometry | null;\n\n        properties: data.Manager;\n\n        state: IDataManager;\n\n        events: IEventManager;\n\n        options: IOptionManager;\n\n        model: TransportSegmentModel;\n\n        getOverlay(): Promise<IOverlay | null>;\n\n        getOverlaySync(): IOverlay | null;\n\n        getParent(): object | null;\n\n        setParent(parent: object): this;\n\n        getMap(): Map;\n      }\n\n      class TransportSegmentModel implements IEventEmitter {\n        events: IEventManager;\n\n        geometry: geometry.base.LineString;\n\n        path: PathModel;\n\n        properties: data.Manager;\n\n        destroy(): void;\n\n        getStops(): StopModel[];\n\n        getType(): string;\n\n        update(segmentJson: object): void;\n      }\n\n      class WalkSegment implements IGeoObject {\n        geometry: IGeometry | null;\n\n        properties: data.Manager;\n\n        state: IDataManager;\n\n        events: IEventManager;\n\n        options: IOptionManager;\n\n        model: WalkSegmentModel;\n\n        getOverlay(): Promise<IOverlay | null>;\n\n        getOverlaySync(): IOverlay | null;\n\n        getParent(): object | null;\n\n        setParent(parent: object): this;\n\n        getMap(): Map;\n      }\n\n      class WalkSegmentModel implements IEventEmitter {\n        events: IEventManager;\n\n        geometry: geometry.base.LineString;\n\n        path: PathModel;\n\n        properties: data.Manager;\n\n        destroy(): void;\n\n        getType(): string;\n      }\n    }\n\n    class EditorAddon implements ICustomizable, IEventEmitter {\n      options: IOptionManager;\n\n      events: IEventManager;\n\n      state: data.Manager;\n\n      isActive(): boolean;\n\n      start(state: object): void;\n\n      stop(): void;\n    }\n\n    class MultiRoute implements IGeoObject {\n      constructor(model: MultiRouteModel | IMultiRouteModelJson, options?: IMultiRouteOptions);\n\n      editor: EditorAddon;\n\n      events: IEventManager;\n\n      geometry: IGeometry | null;\n\n      model: MultiRouteModel;\n\n      options: IOptionManager;\n\n      properties: IDataManager;\n\n      state: IDataManager;\n\n      getActiveRoute(): multiRouter.driving.Route | multiRouter.masstransit.Route | null;\n\n      getBounds(): number[][] | null;\n\n      getMap(): Map;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getParent(): object | null;\n\n      getPixelBounds(): number[][] | null;\n\n      getRoutes(): GeoObjectCollection;\n\n      getViaPoints(): GeoObjectCollection;\n\n      getWayPoints(): GeoObjectCollection;\n\n      setActiveRoute(route: driving.Route | masstransit.Route | null): void;\n\n      setParent(parent: object): this;\n    }\n\n    interface IMultiRouteOptions {\n      activeRouteAutoSelection?: boolean;\n      boundsAutoApply?: boolean;\n      dragUpdateInterval?: string | number;\n      preventDragUpdate?: boolean;\n      useMapMargin?: boolean;\n      zoomMargin?: number[][] | number[] | number;\n\n      [index: string]: any;\n    }\n\n    class MultiRouteModel implements IEventEmitter {\n      constructor(referencePoints: IMultiRouteReferencePoint[], params?: IMultiRouteParams);\n\n      events: IEventManager;\n\n      properties: data.Manager;\n\n      destroy(): void;\n\n      getAllPoints(): Array<WayPointModel | ViaPointModel>;\n\n      getJson(): object;\n\n      getParams(): IMultiRouteParams;\n\n      getPoints(): Array<WayPointModel | ViaPointModel>;\n\n      getReferencePointIndexes(): object;\n\n      getReferencePoints(): IMultiRouteReferencePoint[];\n\n      getRoutes(): driving.RouteModel[] | masstransit.RouteModel[];\n\n      getViaPoints(): ViaPointModel[];\n\n      getWayPoints(): WayPointModel[];\n\n      setParams(params: IMultiRouteParams, extend?: boolean, clearRequests?: boolean): void;\n\n      setReferencePoints(\n        referencePoints: IMultiRouteReferencePoint[],\n        viaIndexes?: number[],\n        clearRequests?: boolean,\n      ): void;\n    }\n\n    class ViaPoint implements IGeoObject {\n      geometry: IGeometry | null;\n\n      properties: data.Manager;\n\n      state: IDataManager;\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getParent(): object | null;\n\n      setParent(parent: object): this;\n\n      getMap(): Map;\n    }\n\n    class ViaPointModel implements IEventEmitter {\n      events: IEventManager;\n\n      geometry: geometry.base.Point;\n\n      multiRoute: MultiRouteModel;\n\n      properties: data.Manager;\n\n      destroy(): void;\n\n      getReferencePoint(): object;\n\n      getReferencePointIndex(): number;\n\n      setReferencePoint(referencePoint: object): void;\n\n      update(viaPointJson: object): void;\n    }\n\n    class WayPoint implements IGeoObject {\n      geometry: IGeometry | null;\n\n      properties: data.Manager;\n\n      state: IDataManager;\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      model: WayPointModel;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getParent(): object | null;\n\n      setParent(parent: object): this;\n\n      getMap(): Map;\n    }\n\n    class WayPointModel implements IEventEmitter {\n      events: IEventManager;\n\n      geometry: geometry.base.Point;\n\n      multiRoute: MultiRouteModel;\n\n      properties: data.Manager;\n\n      destroy(): void;\n\n      getReferencePoint(): object;\n\n      getReferencePointIndex(): number;\n\n      setReferencePoint(referencePoint: object): void;\n\n      update(wayPointJson: object): void;\n    }\n  }\n\n  namespace option {\n    class Manager implements IOptionManager {\n      constructor(options?: object, parent?: IOptionManager, name?: string);\n\n      events: IEventManager;\n\n      get(key: string, defaultValue?: object): object;\n\n      getAll(): object;\n\n      getName(): string;\n\n      getNative(key: string): object;\n\n      resolve(key: string, name?: string): object;\n\n      set(key: object | string, value?: object | number | string | null | undefined): this;\n\n      unset(keys: string[][] | string[] | string): this;\n\n      unsetAll(): this;\n\n      setName(name: string): void;\n\n      getParent(): null | IOptionManager;\n\n      setParent(parent: IOptionManager): this;\n\n      freeze(): IFreezable;\n\n      isFrozen(): boolean;\n\n      unfreeze(): IFreezable;\n\n      add(\n        types: string[][] | string[] | string,\n        callback: (event: object | IEvent) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n\n      group(): IEventGroup;\n\n      remove(\n        types: string[][] | string[] | string,\n        callback: (event: object | IEvent) => void,\n        context?: object,\n        priority?: number,\n      ): this;\n\n      fire(type: string, eventObject: object | IEvent): this;\n    }\n\n    const presetStorage: util.Storage;\n  }\n\n  namespace pane {\n    class EventsPane implements IEventPane {\n      constructor(\n        map: Map,\n        params: {\n          className?: string;\n          css?: CSSStyleDeclaration;\n          patch?: {\n            selectable?: boolean;\n          };\n          transparent?: boolean;\n          checkContextMenu?: boolean;\n          zIndex?: number;\n        },\n      );\n\n      events: IEventManager;\n\n      destroy(): void;\n\n      getElement(): HTMLElement;\n\n      getMap(): Map;\n\n      getOverflow(): 'visible' | 'hidden';\n\n      getZIndex(): number;\n    }\n\n    class MovablePane implements IContainerPane {\n      constructor(\n        map: Map,\n        params: {\n          css?: CSSStyleDeclaration;\n          margin?: number;\n          overflow?: 'hidden' | 'visible';\n          zIndex?: number;\n        },\n      );\n\n      events: IEventManager;\n\n      destroy(): void;\n\n      fromClientPixels(clientPixelPoint: number[]): number[];\n\n      getElement(): HTMLElement;\n\n      getMap(): Map;\n\n      getOverflow(): 'visible' | 'hidden';\n\n      getZIndex(): number;\n\n      getZoom(): number;\n\n      toClientPixels(globalPixelPoint: number[]): number[];\n    }\n\n    class StaticPane implements IContainerPane {\n      constructor(\n        map: Map,\n        params: {\n          css?: CSSStyleDeclaration;\n          margin?: number;\n          overflow?: 'visible' | 'hidden';\n          zIndex?: number;\n        },\n      );\n\n      events: IEventManager;\n\n      destroy(): void;\n\n      fromClientPixels(clientPixelPoint: number[]): number[];\n\n      getElement(): HTMLElement;\n\n      getMap(): Map;\n\n      getOverflow(): 'visible' | 'hidden';\n\n      getZIndex(): number;\n\n      getZoom(): number;\n\n      toClientPixels(globalPixelPoint: number[]): number[];\n    }\n  }\n\n  namespace panorama {\n    type Layer = 'yandex#panorama' | 'yandex#airPanorama';\n\n    class Base implements IPanorama {\n      static createPanorama(params: {\n        angularBBox: number[];\n        coordSystem?: ICoordSystem;\n        name?: string;\n        position: number[];\n        tilesLevels: IPanoramaTileLevel[];\n        tileSize: number[];\n      }): IPanorama;\n\n      static getMarkerPositionFromDirection(\n        panorama: IPanorama,\n        direction: number[],\n        distance: number,\n      ): number[];\n\n      getAngularBBox(): number[];\n\n      getConnectionArrows(): IPanoramaConnectionArrow[];\n\n      getConnectionMarkers(): IPanoramaConnectionMarker[];\n\n      getConnections(): IPanoramaConnectionMarker[];\n\n      getCoordSystem(): ICoordSystem;\n\n      getDefaultDirection(): number[];\n\n      getDefaultSpan(): number[];\n\n      getGraph(): IPanoramaGraph | null;\n\n      getMarkers(): IPanoramaMarker[];\n\n      getName(): string;\n\n      getPosition(): number[];\n\n      getThoroughfares(): IPanoramaConnectionArrow[];\n\n      getTileLevels(): IPanoramaTileLevel[];\n\n      getTileSize(): number[];\n\n      validate(): void;\n    }\n\n    function createPlayer(\n      element: HTMLElement | string,\n      point: number[],\n      options?: {\n        direction?: number[] | string;\n        layer?: Layer;\n        span?: number[] | string;\n      },\n    ): Promise<Player>;\n\n    function isSupported(): boolean;\n\n    function locate(point: number[], options?: { layer?: Layer }): Promise<IPanorama[]>;\n\n    class Manager implements IEventEmitter {\n      events: IEventManager;\n\n      closePlayer(): void;\n\n      disableLookup(): void;\n\n      enableLookup(): void;\n\n      getPlayer(): Player;\n\n      isLookupEnabled(): boolean;\n\n      openPlayer(panorama: IPanorama[] | number): Promise<void>;\n    }\n\n    interface IPlayerOptions {\n      autoFitToViewport?: 'none' | 'ifNull' | 'always';\n      controls?: string[];\n      direction?: number[] | string;\n      hotkeysEnabled?: boolean;\n      scrollZoomBehavior?: boolean;\n      span?: number[] | string;\n      suppressMapOpenBlock?: boolean;\n    }\n\n    class Player implements IEventEmitter {\n      constructor(element: HTMLElement | string, panorama: IPanorama, options?: IPlayerOptions);\n\n      events: IEventManager;\n\n      destroy(): void;\n\n      fitToViewport(): void;\n\n      getDirection(): number[];\n\n      getPanorama(): IPanorama;\n\n      getSpan(): number[];\n\n      lookAt(point: number[]): this;\n\n      moveTo(\n        point: number[],\n        options?: {\n          direction?: number[] | string;\n          layer?: Layer;\n          span?: number[] | string;\n        },\n      ): Promise<void>;\n\n      setDirection(direction: number[] | string): this;\n\n      setPanorama(panorama: IPanorama): this;\n\n      setSpan(span: number[] | string): this;\n    }\n  }\n\n  namespace router {\n    class Editor implements ICustomizable, IEventEmitter {\n      options: IOptionManager;\n\n      events: IEventManager;\n\n      start(options?: {\n        addViaPoints?: boolean;\n        addWayPoints?: boolean;\n        editViaPoints?: boolean;\n        editWayPoints?: boolean;\n        removeViaPoints?: boolean;\n        removeWayPoints?: boolean;\n      }): void;\n\n      stop(): void;\n    }\n\n    abstract class Route implements IGeoObject {\n      geometry: IGeometry | null;\n\n      properties: IDataManager;\n\n      state: IDataManager;\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      editor: Editor;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getParent(): null | IControlParent;\n\n      setParent(parent: IControlParent): this;\n\n      getMap(): Map;\n\n      getHumanJamsTime(): string;\n\n      getHumanLength(): string;\n\n      getHumanTime(): string;\n\n      getJamsTime(): number;\n\n      getLength(): number;\n\n      getPaths(): GeoObjectCollection;\n\n      getTime(): number;\n\n      getViaPoints(): GeoObjectCollection;\n\n      getWayPoints(): GeoObjectCollection;\n    }\n  }\n\n  namespace shape {\n    class Circle implements IShape {\n      constructor(\n        pixelGeometry: IPixelCircleGeometry,\n        params?: {\n          fill?: boolean;\n          outline?: boolean;\n          strokeWidth?: number;\n        },\n      );\n\n      contains(position: number[]): boolean;\n\n      equals(shape: IShape): boolean;\n\n      getBounds(): number[][] | null;\n\n      getGeometry(): IPixelGeometry;\n\n      getType(): string;\n\n      scale(factor: number): IShape;\n\n      shift(offset: number[]): IShape;\n    }\n\n    class LineString implements IShape {\n      constructor(\n        pixelGeometry: IPixelLineStringGeometry,\n        params?: {\n          strokeWidth?: number;\n        },\n      );\n\n      contains(position: number[]): boolean;\n\n      equals(shape: IShape): boolean;\n\n      getBounds(): number[][] | null;\n\n      getGeometry(): IPixelGeometry;\n\n      getType(): string;\n\n      scale(factor: number): IShape;\n\n      shift(offset: number[]): IShape;\n    }\n\n    class MultiPolygon implements IShape {\n      constructor(\n        pixelGeometry: IPixelMultiPolygonGeometry,\n        params?: {\n          fill?: boolean;\n          outline?: boolean;\n          strokeWidth?: number;\n        },\n      );\n\n      contains(position: number[]): boolean;\n\n      equals(shape: IShape): boolean;\n\n      getBounds(): number[][] | null;\n\n      getGeometry(): IPixelGeometry;\n\n      getType(): string;\n\n      scale(factor: number): IShape;\n\n      shift(offset: number[]): IShape;\n    }\n\n    class Polygon implements IShape {\n      constructor(\n        pixelGeometry: IPixelPolygonGeometry,\n        params?: {\n          fill?: boolean;\n          outline?: boolean;\n          strokeWidth?: number;\n        },\n      );\n\n      contains(position: number[]): boolean;\n\n      equals(shape: IShape): boolean;\n\n      getBounds(): number[][] | null;\n\n      getGeometry(): IPixelGeometry;\n\n      getType(): string;\n\n      scale(factor: number): IShape;\n\n      shift(offset: number[]): IShape;\n    }\n\n    class Rectangle implements IShape {\n      constructor(\n        geometry: IPixelRectangleGeometry,\n        params?: {\n          fill?: boolean;\n          outline?: boolean;\n          strokeWidth?: number;\n        },\n      );\n\n      contains(position: number[]): boolean;\n\n      equals(shape: IShape): boolean;\n\n      getBounds(): number[][] | null;\n\n      getGeometry(): IPixelGeometry;\n\n      getType(): string;\n\n      scale(factor: number): IShape;\n\n      shift(offset: number[]): IShape;\n    }\n  }\n\n  interface meta {\n    coordinatesOrder: 'latlong' | 'longlat';\n    countryCode: string;\n    languageCode: string;\n    mode: 'release' | 'debug';\n    ns: typeof ymaps;\n    version: string;\n  }\n\n  class Balloon extends Popup<Balloon> implements IBaloon<Balloon>, IBalloonManager<Balloon> {\n    constructor(map: Map, options?: IBalloonOptions);\n\n    getData(): object;\n\n    close(force?: boolean): Promise<Balloon>;\n\n    getParent(): Balloon | null;\n\n    setParent(parent: Balloon): this;\n\n    autoPan(): Promise<Balloon>;\n\n    freeze(): IFreezable;\n\n    isFrozen(): boolean;\n\n    unfreeze(): IFreezable;\n\n    add(\n      types: string[][] | string[] | string,\n      callback: (event: object | IEvent) => void,\n      context?: object,\n      priority?: number,\n    ): this;\n\n    group(): IEventGroup;\n\n    remove(\n      types: string[][] | string[] | string,\n      callback: (event: object | IEvent) => void,\n      context?: object,\n      priority?: number,\n    ): this;\n\n    fire(type: string, eventObject: object | IEvent): this;\n\n    destroy(): void;\n\n    getOptions(): IOptionManager | null;\n\n    setOptions(options: object): Promise<Balloon>;\n  }\n\n  interface IBalloonOptions {\n    autoPan?: boolean;\n    autoPanCheckZoomRange?: boolean;\n    autoPanDuration?: number;\n    autoPanMargin?: number | number[] | undefined;\n    autoPanUseMapMargin?: boolean;\n    closeButton?: boolean;\n    closeTimeout?: number | undefined;\n    contentLayout?: IClassConstructor<ILayout> | string;\n    interactivityModel?: InteractivityModelKey | undefined;\n    layout?: IClassConstructor<ILayout> | string;\n    maxHeight?: number;\n    maxWidth?: number;\n    minHeight?: number;\n    minWidth?: number;\n    offset?: number[];\n    openTimeout?: number | undefined;\n    pane?: string;\n    panelContentLayout?: IClassConstructor<ILayout> | string;\n    panelMaxHeightRatio?: number;\n    panelMaxMapArea?: number;\n    shadow?: boolean;\n    shadowLayout?: IClassConstructor<ILayout> | string;\n    shadowOffset?: number[];\n    zIndex?: string | undefined;\n  }\n\n  interface IBalloonOptionsWithBalloonPrefix {\n    balloonContent?: string | undefined;\n    balloonAutoPan?: boolean | undefined;\n    balloonAutoPanCheckZoomRange?: boolean | undefined;\n    balloonAutoPanDuration?: number | undefined;\n    balloonAutoPanMargin?: number | number[] | undefined;\n    balloonAutoPanUseMapMargin?: boolean | undefined;\n    balloonCloseButton?: boolean | undefined;\n    balloonCloseTimeout?: number | undefined;\n    balloonContentLayout?: IClassConstructor<ILayout> | string | undefined;\n    balloonInteractivityModel?: InteractivityModelKey | undefined;\n    balloonLayout?: IClassConstructor<ILayout> | string | undefined;\n    balloonMaxHeight?: number | undefined;\n    balloonMaxWidth?: number | undefined;\n    balloonMinHeight?: number | undefined;\n    balloonMinWidth?: number | undefined;\n    balloonOffset?: number[] | undefined;\n    balloonOpenTimeout?: number | undefined;\n    balloonPane?: string | undefined;\n    balloonPanelContentLayout?: IClassConstructor<ILayout> | string | undefined;\n    balloonPanelMaxHeightRatio?: number | undefined;\n    balloonPanelMaxMapArea?: number | undefined;\n    balloonShadow?: boolean | undefined;\n    balloonShadowLayout?: IClassConstructor<ILayout> | string | undefined;\n    balloonShadowOffset?: number[] | undefined;\n    balloonZIndex?: string | undefined;\n  }\n\n  class Circle implements GeoObject<ICircleGeometry> {\n    constructor(\n      geometry: ICircleGeometry[][][][] | number[][] | object,\n      properties?: object | IDataManager,\n      options?: ICircleOptions,\n    );\n\n    balloon: geoObject.Balloon;\n\n    editor: IGeometryEditor;\n\n    hint: geoObject.Hint;\n\n    events: event.Manager;\n\n    options: option.Manager;\n\n    properties: data.Manager;\n\n    state: data.Manager;\n\n    geometry: ICircleGeometry | null;\n\n    indices: ArrayBuffer;\n\n    vertices: ArrayBuffer;\n\n    getOverlay(): Promise<IOverlay | null>;\n\n    getOverlaySync(): IOverlay | null;\n\n    getParent(): null | IControlParent;\n\n    setParent(parent: IControlParent): this;\n\n    getMap(): Map;\n  }\n\n  interface ICircleOptions {\n    circleOverlay?:\n      | string\n      | ((geometry: IPixelCircleGeometry, data: object, options: object) => Promise<IOverlay>);\n    cursor?: string;\n    draggable?: boolean;\n    fill?: boolean;\n    fillColor?: string;\n    fillImageHref?: string;\n    fillMethod?: 'stretch' | 'tile';\n    fillOpacity?: number;\n    hasBalloon?: boolean;\n    hasHint?: boolean;\n    hideIconOnBalloonOpen?: boolean;\n    interactiveZIndex?: boolean;\n    interactivityModel?: InteractivityModelKey;\n    opacity?: number;\n    openBalloonOnClick?: boolean;\n    openEmptyBalloon?: boolean;\n    openEmptyHint?: boolean;\n    openHintOnHover?: boolean;\n    outline?: boolean;\n    pane?: string;\n    strokeColor?: string[][] | string[] | string;\n    strokeOpacity?: number[][] | number[] | number;\n    strokeStyle?: string[][][] | object[][] | string[] | object[] | string | object;\n    strokeWidth?: number[][] | number[] | number;\n    syncOverlayInit?: boolean;\n    useMapMarginInDragging?: boolean;\n    visible?: boolean;\n    zIndex?: number;\n    zIndexActive?: number;\n    zIndexDrag?: number;\n    zIndexHover?: number;\n  }\n\n  class Clusterer implements IChildOnMap, ICustomizable, IEventEmitter, IParentOnMap {\n    constructor(options?: IClustererOptions);\n\n    events: IEventManager;\n\n    options: option.Manager;\n\n    balloon: clusterer.Balloon;\n\n    hint: clusterer.Hint;\n\n    add(objects: IGeoObject | IGeoObject[]): this;\n\n    createCluster(center: number[], geoObjects: IGeoObject[]): IGeoObject;\n\n    getBounds(): number[][] | null;\n\n    getClusters(): IGeoObject[];\n\n    getGeoObjects(): IGeoObject[];\n\n    getMap(): Map;\n\n    getObjectState(geoObject: IGeoObject): { isShown: boolean; cluster: any; isClustered: boolean };\n\n    getParent(): IParentOnMap | null;\n\n    remove(objects: IGeoObject | IGeoObject[]): this;\n\n    removeAll(): this;\n\n    setParent(parent: IControlParent): this;\n  }\n\n  interface IClustererOptionsInject {\n    gridSize?: number;\n    groupByCoordinates?: boolean;\n    hasBalloon?: boolean;\n    hasHint?: boolean;\n    margin?: number[] | number | undefined;\n    maxZoom?: number[] | number;\n    minClusterSize?: number;\n    preset?: PresetKey;\n    showInAlphabeticalOrder?: boolean;\n    useMapMargin?: boolean;\n    viewportMargin?: number[] | number | undefined;\n    zoomMargin?: number[] | number | undefined;\n  }\n\n  interface IClustererOptions\n    extends IClustererOptionsInject,\n      IClusterPlacemarkOptionsWithClusterPrefix {\n    hasBalloon?: boolean | undefined;\n    hasHint?: boolean | undefined;\n\n    [key: string]: any;\n  }\n\n  class ClusterPlacemark implements IGeoObject, collection.Item {\n    constructor(\n      geometry: number[] | object | IPointGeometry,\n      properties: IClusterPlacemarkProperties,\n      options?: IClusterPlacemarkOptions,\n    );\n\n    geometry: IGeometry | null;\n\n    properties: IDataManager;\n\n    events: IEventManager;\n\n    options: IOptionManager;\n\n    state: data.Manager;\n\n    getOverlay(): Promise<IOverlay | null>;\n\n    getOverlaySync(): IOverlay | null;\n\n    getParent(): null | IControlParent;\n\n    setParent(parent: IControlParent): this;\n\n    getMap(): Map;\n\n    onAddToMap(map: Map): void;\n\n    onRemoveFromMap(oldMap: Map): void;\n\n    getBounds(): number[][] | null;\n\n    getGeoObjects(): IGeoObject[];\n  }\n\n  interface IClusterPlacemarkProperties extends IDataManager {\n    geoObjects: IGeoObject[];\n  }\n\n  interface IClusterPlacemarkOptions {\n    balloonContentLayout?: IClassConstructor<ILayout> | ClusterLayoutKey | undefined;\n    balloonContentLayoutHeight?: number;\n    balloonContentLayoutWidth?: number;\n    balloonItemContentLayout?: ILayout | ClusterContentLayoutKey | undefined;\n    balloonPanelContentLayout?: IClassConstructor<ILayout> | ClusterLayoutKey | undefined;\n    cursor?: string;\n    disableClickZoom?: boolean;\n    hideIconOnBalloonOpen?: boolean;\n    iconColor?: string;\n    iconContentLayout?: string | IClassConstructor<ILayout>;\n    iconLayout?: string | IClassConstructor<ILayout>;\n    icons?: {\n      href: string;\n      size: number[];\n      offset: number[];\n      shape?: IShape | IGeometryJson;\n    }[];\n    iconShape?: IGeometryJson;\n    interactivityModel?: InteractivityModelKey;\n    numbers?: number[];\n    openBalloonOnClick?: boolean;\n    openEmptyHint?: boolean;\n    openHintOnHover?: boolean;\n    zIndexHover?: number;\n  }\n\n  interface IClusterPlacemarkOptionsWithClusterPrefix {\n    clusterBalloonContentLayout?: IClassConstructor<ILayout> | ClusterLayoutKey | undefined;\n    clusterBalloonContentLayoutHeight?: number | undefined;\n    clusterBalloonContentLayoutWidth?: number | undefined;\n    clusterBalloonItemContentLayout?: ILayout | ClusterContentLayoutKey | undefined;\n    clusterBalloonPanelContentLayout?: IClassConstructor<ILayout> | ClusterLayoutKey | undefined;\n    clusterCursor?: string | undefined;\n    clusterDisableClickZoom?: boolean | undefined;\n    clusterHideIconOnBalloonOpen?: boolean | undefined;\n    clusterIconColor?: string | undefined;\n    clusterIconContentLayout?: IClassConstructor<ILayout> | string | undefined;\n    clusterIconLayout?: IClassConstructor<ILayout> | string | undefined;\n    clusterIcons?: {\n      href: string;\n      size: number[];\n      offset: number[];\n      shape?: IShape | IGeometryJson | undefined;\n    }[];\n    clusterIconShape?: IGeometryJson | undefined;\n    clusterInteractivityModel?: InteractivityModelKey | undefined;\n    clusterNumbers?: number[] | undefined;\n    clusterOpenBalloonOnClick?: boolean | undefined;\n    clusterOpenEmptyHint?: boolean | undefined;\n    clusterOpenHintOnHover?: boolean | undefined;\n    clusterZIndexHover?: number | undefined;\n  }\n\n  class Collection<T = {}> implements ICollection, collection.Item {\n    constructor(options?: object);\n\n    events: IEventManager;\n\n    options: IOptionManager;\n\n    add(object: object): this;\n\n    getIterator(): IIterator;\n\n    remove(object: object): this;\n\n    getParent(): null | IControlParent;\n\n    setParent(parent: IControlParent): this;\n\n    getMap(): Map;\n\n    onAddToMap(map: Map): void;\n\n    onRemoveFromMap(oldMap: Map): void;\n\n    filter(filterFunction: (object: object) => boolean): object[];\n\n    get(index: number): object;\n\n    getAll(): T[];\n\n    getLength(): number;\n\n    indexOf(childToFind: object): number;\n\n    removeAll(): this;\n  }\n\n  class Event<OriginalEvent = {}, TargetGeometry = {}>\n    implements IEvent<OriginalEvent, TargetGeometry>\n  {\n    constructor(originalEvent: object, sourceEvent: IEvent);\n\n    originalEvent: {\n      domEvent: {\n        originalEvent: OriginalEvent;\n      };\n      target: {\n        geometry?: TargetGeometry;\n      };\n    };\n\n    allowMapEvent(): void;\n\n    callMethod(name: string): void;\n\n    get<T extends OriginalEvent, K extends keyof T = keyof T>(name: K): T[K];\n\n    get(name: string): any;\n\n    getSourceEvent(): IEvent<OriginalEvent, TargetGeometry> | null;\n\n    isDefaultPrevented(): boolean;\n\n    isImmediatePropagationStopped(): boolean;\n\n    isMapEventAllowed(): boolean;\n\n    isPropagationStopped(): boolean;\n\n    preventDefault(): boolean;\n\n    stopImmediatePropagation(): boolean;\n\n    stopPropagation(): boolean;\n  }\n\n  class DomEvent<OriginalEvent = {}, TargetGeometry = {}>\n    implements IDomEvent<OriginalEvent, TargetGeometry>\n  {\n    constructor(originalEvent: DomEvent, type?: object);\n\n    originalEvent: {\n      domEvent: {\n        originalEvent: OriginalEvent;\n      };\n      target: {\n        geometry?: TargetGeometry | undefined;\n      };\n    };\n\n    allowMapEvent(): void;\n\n    callMethod(name: string): void;\n\n    get<T extends OriginalEvent, K extends keyof T = keyof T>(name: K): T[K];\n    get(name: string): any;\n\n    getSourceEvent(): IDomEvent<OriginalEvent, TargetGeometry>;\n\n    isDefaultPrevented(): boolean;\n\n    isImmediatePropagationStopped(): boolean;\n\n    isMapEventAllowed(): boolean;\n\n    isPropagationStopped(): boolean;\n\n    preventDefault(): boolean;\n\n    stopImmediatePropagation(): boolean;\n\n    stopPropagation(): boolean;\n  }\n\n  class GeoObject<T = IGeometry, TargetGeometry = {}> implements IGeoObject<T> {\n    constructor(feature?: IGeoObjectFeature, options?: IGeoObjectOptions);\n\n    geometry: T | null;\n\n    balloon: geoObject.Balloon;\n\n    editor: IGeometryEditor;\n\n    hint: geoObject.Hint;\n\n    events: event.Manager<TargetGeometry>;\n\n    options: option.Manager;\n\n    properties: data.Manager;\n\n    state: data.Manager;\n\n    getOverlay(): Promise<IOverlay | null>;\n\n    getOverlaySync(): IOverlay | null;\n\n    getParent(): null | IControlParent;\n\n    setParent(parent: IControlParent): this;\n\n    getMap(): Map;\n  }\n\n  interface IGeoObjectFeature {\n    geometry?: IGeometry | IGeometryJson;\n    properties?: IDataManager | object;\n  }\n\n  interface IGeoObjectOptions\n    extends IBalloonOptionsWithBalloonPrefix,\n      IHintOptionsWithHintPrefix,\n      ICircleOptions {\n    iconCaptionMaxWidth?: number;\n    iconColor?: string;\n    iconContentLayout?: string | IClassConstructor<ILayout>;\n    iconContentOffset?: number[];\n    iconContentPadding?: number[];\n    iconContentSize?: number[];\n    iconImageClipRect?: number[][];\n    iconImageHref?: string;\n    iconImageOffset?: number[];\n    iconImageShape?: IShape | null;\n    iconImageSize?: number[];\n    iconLayout?: string | IClassConstructor<ILayout>;\n    iconMaxHeight?: number;\n    iconMaxWidth?: number;\n    iconOffset?: number[];\n    iconShadow?: boolean;\n    iconShadowImageClipRect?: number[][];\n    iconShadowImageHref?: string;\n    iconShadowImageOffset?: number[];\n    iconShadowImageSize?: number[];\n    iconShadowLayout?: string | IClassConstructor<ILayout>;\n    iconShadowOffset?: number[];\n    lineStringOverlay?: OverlayKey;\n    pointOverlay?: OverlayKey;\n    polygonOverlay?: OverlayKey;\n    preset?: PresetKey | undefined;\n    rectangleOverlay?: OverlayKey;\n    setMapCursorInDragging?: boolean;\n\n    [key: string]: any;\n  }\n\n  class GeoObjectCollection implements IGeoObject, IGeoObjectCollection {\n    constructor(\n      feature?: {\n        children?: IGeoObject[];\n        geometry?: IGeometry | object;\n        properties?: IDataManager | object;\n      },\n      options?: object,\n    );\n\n    geometry: IGeometry | null;\n\n    properties: IDataManager;\n\n    state: IDataManager;\n\n    events: IEventManager;\n\n    options: IOptionManager;\n\n    getOverlay(): Promise<IOverlay | null>;\n\n    getOverlaySync(): IOverlay | null;\n\n    getParent(): null | IControlParent;\n\n    setParent(parent: IControlParent): this;\n\n    getMap(): Map;\n\n    add(child: IGeoObject, index?: number): this;\n\n    each(callback: (object: IGeoObject) => void, context?: object): void;\n\n    get(index: number): IGeoObject;\n\n    getBounds(): number[][] | null;\n\n    getIterator(): IIterator;\n\n    getLength(): number;\n\n    getPixelBounds(): number[][] | null;\n\n    indexOf(object: IGeoObject): number;\n\n    remove(child: IGeoObject): this;\n\n    removeAll(): this;\n\n    set(index: number, child: IGeoObject): this;\n\n    splice(index: number, length: number): this;\n\n    toArray(): IGeoObject[];\n  }\n\n  interface ILayerOptions {\n    brightness?: number;\n    notFoundTile?: string | null;\n    pane?: IPane | string;\n    projection?: any;\n    tileSize?: number[][];\n    tileTransparent?: boolean;\n    zIndex?: number;\n  }\n\n  class Layer implements ILayer, IParentOnMap, IPositioningContext {\n    constructor(\n      tileUrlTemplate: string | ((tileNumber: number[], tileZoom: number) => string),\n      options?: ILayerOptions,\n    );\n\n    events: IEventManager;\n\n    options: IOptionManager;\n\n    clientPixelsToNumber(clientPixelPoint: number, tileZoom: number): number[];\n\n    fromClientPixels(clientPixelPoint: number[]): number[];\n\n    getBrightness?(): number;\n\n    getCopyrights?(coords: number[], zoom: number): Promise<Array<string | HTMLElement>>;\n\n    getMap(): Map;\n\n    getPane(): IPane;\n\n    getParent(): null | IControlParent;\n\n    getTileSize(zoom: number): number[];\n\n    getTileStatus(): { readyTileNumber: number; totalTileNumber: number };\n\n    getTileUrl(tileNumber: number[], tileZoom: number): string | null;\n\n    getTileUrlTemplate(): string | any;\n\n    getZoom(): number;\n\n    getZoomRange?(point: number[]): Promise<number[]>;\n\n    numberToClientBounds(tileNumber: number[], tileZoom: number): number[][];\n\n    restrict(num: number[], tileZoom: number): number[] | null;\n\n    setParent(parent: IControlParent): this;\n\n    setTileUrlTemplate(tileUrlTemplate: string | any): void;\n\n    toClientPixels(globalPixelPoint: number[]): number[];\n\n    update(updateBounds: any): void;\n\n    getAlias(): string;\n\n    getElement(): HTMLElement;\n  }\n\n  type IHint = IPopup<IHint>;\n\n  interface IHintOptions {\n    closeTimeout?: number;\n    contentLayout?: IClassConstructor<ILayout> | string;\n    fitPane?: boolean;\n    holdByMouse?: boolean;\n    interactivityModel?: InteractivityModelKey;\n    layout?: IClassConstructor<ILayout> | string;\n    offset?: number[];\n    openTimeout?: number;\n    pane?: string;\n    zIndex?: number;\n  }\n\n  interface IHintOptionsWithHintPrefix {\n    hintCloseTimeout?: number;\n    hintContentLayout?: IClassConstructor<ILayout> | string;\n    hintFitPane?: boolean;\n    hintHoldByMouse?: boolean;\n    hintInteractivityModel?: InteractivityModelKey;\n    hintLayout?: IClassConstructor<ILayout> | string;\n    hintOffset?: number[];\n    hintOpenTimeout?: number;\n    hintPane?: string;\n    hintZIndex?: number;\n  }\n\n  class Hint extends Popup<Hint> implements IHint {\n    constructor(map: Map, options?: IHintOptions);\n  }\n\n  class Map implements IDomEventEmitter {\n    constructor(parentElement: HTMLElement | string, state: IMapState, options?: IMapOptions);\n\n    action: map.action.Manager;\n\n    balloon: map.Balloon;\n\n    behaviors: map.behavior.Manager;\n\n    container: map.Container;\n\n    controls: control.Manager;\n\n    converter: map.Converter;\n\n    copyrights: map.Copyrights;\n\n    cursors: util.cursor.Manager;\n\n    events: event.Manager;\n\n    geoObjects: map.GeoObjects;\n\n    hint: map.Hint;\n\n    layers: map.layer.Manager;\n\n    margin: map.margin.Manager;\n\n    options: option.Manager;\n\n    panes: map.pane.Manager;\n\n    zoomRange: map.ZoomRange;\n\n    destroy(): void;\n\n    getBounds(options?: IMapMarginOptions): number[][];\n\n    getCenter(options?: IMapMarginOptions): number[];\n\n    getGlobalPixelCenter(options?: IMapMarginOptions): number[];\n\n    getPanoramaManager(): Promise<panorama.Manager>;\n\n    getType(): string | MapType;\n\n    getZoom(): number;\n\n    panTo(center: number[] | object[], options?: IMapPanOptions): this;\n\n    setBounds(bounds: number[][], options?: IMapBoundsOptions): this;\n\n    setCenter(center: number[], zoom?: number, options?: IMapPositionOptions): this;\n\n    setGlobalPixelCenter(\n      globalPixelCenter: number[],\n      zoom?: number,\n      options?: IMapPositionOptions,\n    ): this;\n\n    setType(type: string | MapType, options?: IMapCheckZoomRangeOptions): this;\n\n    setZoom(zoom: number, options?: IMapZoomOptions): this;\n  }\n\n  class MapEvent<OriginalEvent = {}, TargetGeometry = {}> extends Event<\n    OriginalEvent,\n    TargetGeometry\n  > {\n    get(name: string): any;\n    get(name: 'coords' | 'globalPixels' | 'pagePixels' | 'clientPixels'): [number, number];\n    get(name: 'domEvent'): DomEvent<OriginalEvent, TargetGeometry> | undefined;\n  }\n\n  interface IMapMarginOptions {\n    useMapMargin?: boolean;\n  }\n\n  interface IMapCheckZoomRangeOptions {\n    checkZoomRange?: boolean;\n  }\n\n  interface IMapZoomOptions extends IMapMarginOptions, IMapCheckZoomRangeOptions {\n    duration?: number;\n  }\n\n  interface IMapPositionOptions extends IMapZoomOptions {\n    timingFunction?: string;\n  }\n\n  interface IMapBoundsOptions extends IMapPositionOptions {\n    preciseZoom?: boolean;\n    zoomMargin?: number[][] | number[];\n  }\n\n  interface IMapPanOptions extends IMapPositionOptions {\n    delay?: number;\n    flying?: boolean;\n    safe?: boolean;\n  }\n\n  class MapType {\n    constructor(name: string, layers: Array<IClassConstructor<Layer> | string>);\n  }\n\n  interface IMapState {\n    behaviors?: string[];\n    bounds?: number[][];\n    center?: number[];\n    controls?: ControlKey[];\n    margin?: number | number[];\n    type?: 'yandex#map' | 'yandex#satellite' | 'yandex#hybrid' | MapType;\n    zoom?: number;\n  }\n\n  interface IMapOptions {\n    autoFitToViewport?: 'none' | 'ifNull' | 'always';\n    avoidFractionalZoom?: boolean;\n    exitFullscreenByEsc?: boolean;\n    fullscreenZIndex?: number;\n    mapAutoFocus?: boolean;\n    maxAnimationZoomDifference?: number;\n    maxZoom?: number;\n    minZoom?: number;\n    nativeFullscreen?: boolean;\n    projection?: IProjection;\n    restrictMapArea?: boolean | number[][] | undefined;\n    suppressMapOpenBlock?: boolean;\n    suppressObsoleteBrowserNotifier?: boolean;\n    yandexMapAutoSwitch?: boolean;\n    yandexMapDisablePoiInteractivity?: boolean;\n\n    copyrightLogoVisible?: boolean;\n    copyrightProvidersVisible?: boolean;\n    copyrightUaVisible?: boolean;\n  }\n\n  class Placemark extends GeoObject<IPointGeometry, geometry.Point> {\n    constructor(\n      geometry: number[] | object | IPointGeometry,\n      properties?: IPlacemarkProperties | IDataManager,\n      options?: IPlacemarkOptions,\n    );\n  }\n\n  interface IPlacemarkProperties {\n    iconContent?: string;\n    iconCaption?: string;\n    hintContent?: string;\n    balloonContent?: string;\n    balloonContentHeader?: string;\n    balloonContentBody?: string;\n    balloonContentFooter?: string;\n    [key: string]: any;\n  }\n\n  interface IPlacemarkOptions\n    extends layout.IImageOptionsWithIconPrefix,\n      layout.IImageWithContentOptionsWithIconPrefix,\n      layout.IPieChartOptionsWithIconPrefix,\n      IBalloonOptionsWithBalloonPrefix,\n      IHintOptionsWithHintPrefix {\n    cursor?: string;\n    draggable?: boolean;\n    hasBalloon?: boolean;\n    hasHint?: boolean;\n    hideIconOnBalloonOpen?: boolean;\n    iconColor?: string | undefined;\n    iconLayout?: IClassConstructor<ILayout> | IconLayoutKey | undefined;\n    iconOffset?: number[];\n    iconShape?: IGeometryJson | null;\n    interactiveZIndex?: boolean;\n    interactivityModel?: InteractivityModelKey | undefined;\n    openBalloonOnClick?: boolean;\n    openEmptyBalloon?: boolean;\n    openEmptyHint?: boolean;\n    openHintOnHover?: boolean;\n    pane?: string;\n    pointOverlay?: string;\n    preset?: PresetKey | undefined;\n    syncOverlayInit?: boolean;\n    useMapMarginInDragging?: boolean;\n    visible?: boolean;\n    zIndex?: number;\n    zIndexActive?: number;\n    zIndexDrag?: number;\n    zIndexHover?: number;\n\n    [key: string]: any;\n  }\n\n  class Polygon extends GeoObject<IPolygonGeometry> {\n    constructor(\n      geometry: number[][][] | object | IPolygonGeometry,\n      properties?: object | IDataManager,\n      options?: IPolygonOptions,\n    );\n  }\n\n  interface IPolygonOptions {\n    cursor?: string;\n    draggable?: boolean;\n    fill?: boolean;\n    fillColor?: string;\n    fillImageHref?: string;\n    fillMethod?: 'stretch' | 'tile';\n    fillOpacity?: number;\n    hasBalloon?: boolean;\n    hasHint?: boolean;\n    interactiveZIndex?: boolean;\n    interactivityModel?: InteractivityModelKey | undefined;\n    opacity?: number;\n    openBalloonOnClick?: boolean;\n    openEmptyBalloon?: boolean;\n    openEmptyHint?: boolean;\n    openHintOnHover?: boolean;\n    outline?: boolean;\n    pane?: string;\n    polygonOverlay?: string;\n    strokeColor?: string | string[];\n    strokeOpacity?: number | number[];\n    strokeStyle?: string | string[] | object | object[];\n    strokeWidth?: number | number[];\n    syncOverlayInit?: boolean;\n    useMapMarginInDragging?: boolean;\n    visible?: boolean;\n    zIndex?: number;\n    zIndexActive?: number;\n    zIndexDrag?: number;\n    zIndexHover?: number;\n  }\n\n  class Polyline extends GeoObject<ILineStringGeometry> {\n    constructor(\n      geometry: number[][] | object | ILineStringGeometry,\n      properties?: object | IDataManager,\n      options?: IPolylineOptions,\n    );\n  }\n\n  interface IPolylineOptions {\n    cursor?: string;\n    draggable?: boolean;\n    hasBalloon?: boolean;\n    hasHint?: boolean;\n    interactiveZIndex?: boolean;\n    interactivityModel?: InteractivityModelKey | undefined;\n    lineStringOverlay?: () => object | string;\n    opacity?: number;\n    openBalloonOnClick?: boolean;\n    openEmptyBalloon?: boolean;\n    openEmptyHint?: boolean;\n    openHintOnHover?: boolean;\n    pane?: string;\n    strokeColor?: string | string[];\n    strokeOpacity?: number | number[];\n    strokeStyle?: string | string[] | object | object[];\n    strokeWidth?: number | number[];\n    syncOverlayInit?: boolean;\n    useMapMarginInDragging?: boolean;\n    visible?: boolean;\n    zIndex?: number;\n    zIndexActive?: number;\n    zIndexDrag?: number;\n    zIndexHover?: number;\n  }\n\n  class Popup<T> implements IPopup<T> {\n    constructor(map: Map, options?: IPopupOptions);\n\n    options: IOptionManager;\n\n    events: IEventManager;\n\n    close(force?: boolean): Promise<T>;\n\n    getData(): object;\n\n    getOverlay(): Promise<IOverlay>;\n\n    getOverlaySync(): IOverlay;\n\n    getPosition(): number[];\n\n    isOpen(): boolean;\n\n    open(position: number[], data: object | string | HTMLElement): Promise<T>;\n\n    setData(data: object | string | HTMLElement): Promise<T>;\n\n    setPosition(position: number[]): Promise<T>;\n  }\n\n  interface IPopupOptions {\n    closeTimeout?: number;\n    interactivityModel?: InteractivityModelKey;\n    openTimeout?: number;\n    pane?: IPane | string;\n    projection?: IProjection;\n    zIndex?: number;\n  }\n\n  function ready(\n    successCallback?: () => any | IReadyObject,\n    errorCallback?: () => any,\n    context?: object,\n  ): Promise<void>;\n\n  interface IReadyObject {\n    require?: string[];\n    context?: object;\n\n    successCallback?(): void;\n\n    errorCallback?(): void;\n  }\n\n  interface IRectangleProperties {\n    hintContent?: string;\n    balloonContent?: string;\n    balloonContentHeader?: string;\n    balloonContentBody?: string;\n    balloonContentFooter?: string;\n  }\n\n  interface IRectangleOptions extends IBalloonOptionsWithBalloonPrefix, IHintOptionsWithHintPrefix {\n    cursor?: string;\n    draggable?: boolean;\n    fill?: boolean;\n    fillColor?: string;\n    fillImageHref?: string;\n    fillMethod?: string;\n    fillOpacity?: number;\n    hasBalloon?: boolean;\n    hasHint?: boolean;\n    interactiveZIndex?: boolean;\n    interactivityModel?: InteractivityModelKey;\n    opacity?: number;\n    openBalloonOnClick?: boolean;\n    openEmptyBalloon?: boolean;\n    openEmptyHint?: boolean;\n    openHintOnHover?: boolean;\n    outline?: boolean;\n    pane?: string;\n    rectangleOverlay?:\n      | OverlayKey\n      | ((\n      geometry: IPixelCircleGeometry,\n      data: IDataManager | object,\n      options: object,\n    ) => vow.Promise);\n    strokeColor?: string | string[];\n    strokeOpacity?: number | number[];\n    strokeStyle?: string | string[] | object | object[];\n    strokeWidth?: number | number[];\n    syncOverlayInit?: boolean;\n    useMapMarginInDragging?: boolean;\n    visible?: boolean;\n    zIndex?: number;\n    zIndexActive?: number;\n    zIndexDrag?: number;\n    zIndexHover?: number;\n\n    [key: string]: any;\n  }\n\n  interface IRectangleGeometryAccess extends IFreezable {\n    contains(position: number[]): boolean;\n\n    getClosest(anchorPosition: number[]): object;\n\n    getCoordinates(): number[][];\n\n    setCoordinates(coordinates: number[][]): IRectangleGeometryAccess;\n  }\n\n  interface IRectangleGeometry extends IGeometry, IRectangleGeometryAccess {\n    getType(): string;\n  }\n\n  class Rectangle extends GeoObject<ILineStringGeometry> {\n    constructor(\n      geometry: number[][] | object | IRectangleGeometry,\n      properties?: IRectangleProperties | IDataManager,\n      options?: IRectangleOptions,\n    );\n  }\n\n  namespace regions {\n    function load(\n      region: string,\n      options?: {\n        disputedBorders?: string;\n        lang?: string;\n        quality?: number;\n      },\n    ): vow.Promise;\n  }\n\n  namespace templateLayoutFactory {\n    function createClass<O extends {} = {}, S extends {} = {}>(\n      template: string,\n      overrides?: O,\n      staticMethods?: S,\n    ): IClassConstructor<layout.templateBased.Base & O & S>;\n  }\n\n  type ResolveCallbackFunction = (\n    provide: (module: any, error?: any) => void,\n    ...depends: any[]\n  ) => void;\n\n  interface IRatioMap {\n    [key: string]: string;\n  }\n\n  namespace util {\n    class AsyncStorage extends Storage {\n      define(\n        key: string,\n        depends: string[],\n        resolveCallback: ResolveCallbackFunction,\n        context?: object,\n      ): this;\n\n      define(key: string, resolveCallback: ResolveCallbackFunction, context?: object): this;\n\n      isDefined(key: string): boolean;\n\n      require(\n        keys: string | string[],\n        successCallback?: (...args: any[]) => void,\n        errorCallback?: (error: any) => void,\n        context?: object,\n      ): vow.Promise;\n    }\n\n    function augment(ChildClass: any, ParentClass: any, override: object): any;\n\n    function bind(callback: any, context: object): any;\n\n    const bounds: {\n      areIntersecting(\n        bounds1: number[][],\n        bounds2: number[][],\n        projection?: typeof ymaps.projection.wgs84Mercator,\n      ): boolean;\n\n      containsBounds(\n        outer: number[][],\n        inner: number[][],\n        projection?: typeof ymaps.projection.wgs84Mercator,\n      ): boolean;\n\n      containsPoint(\n        bounds: number[][],\n        point: number[],\n        projection?: typeof ymaps.projection.wgs84Mercator,\n      ): boolean;\n\n      fromBounds(\n        sourceBounds: number[][],\n        projection?: typeof ymaps.projection.wgs84Mercator,\n      ): number[][];\n\n      fromGlobalPixelBounds(\n        pixelBounds: number[][],\n        zoom: number,\n        projection?: typeof ymaps.projection.wgs84Mercator,\n      ): number[][];\n\n      fromPoints(\n        points: number[][],\n        projection?: typeof ymaps.projection.wgs84Mercator,\n      ): number[][];\n\n      getCenter(bounds: number[][], projection?: typeof ymaps.projection.wgs84Mercator): number[];\n\n      getCenterAndZoom(\n        bounds: number[][],\n        containerSize: number[],\n        projection?: typeof ymaps.projection.wgs84Mercator,\n        params?: {\n          inscribe?: boolean;\n          margin?: number | number[];\n          preciseZoom?: boolean;\n        },\n      ): object;\n\n      getIntersections(\n        bounds1: number[][],\n        bounds2: number[][],\n        projection?: typeof ymaps.projection.wgs84Mercator,\n      ): number[][][];\n\n      getSize(bounds: number[][], projection?: typeof ymaps.projection.wgs84Mercator): number[];\n\n      toGlobalPixelBounds(\n        geoBounds: number[][],\n        zoom: number[],\n        projection?: typeof ymaps.projection.wgs84Mercator,\n      ): number[][];\n    };\n\n    namespace cursor {\n      class Accessor {\n        constructor(key: string);\n\n        getKey(): string;\n\n        remove(): void;\n\n        setKey(key: string): void;\n      }\n\n      class Manager {\n        constructor(element: HTMLElement);\n\n        events: event.Manager;\n\n        push(key: string): Accessor;\n      }\n    }\n\n    function defineClass(constructor: any, parentClass?: any, override?: object): any;\n\n    function defineClass(constructor: any, override?: object): any;\n\n    class Dragger implements IEventEmitter {\n      constructor(params?: {\n        autoStartElement?: HTMLElement | IDomEventEmitter;\n        byRightButton?: boolean;\n        tremor?: number;\n      });\n\n      events: IEventManager;\n\n      destroy(): void;\n\n      isDragging(): boolean;\n\n      start(event: IDomEvent): void;\n\n      stop(): void;\n    }\n\n    function extend(target: object, ...source: object[]): object;\n\n    const hd: {\n      getPixelRatio(): number;\n\n      selectRatio(hash: IRatioMap): number;\n\n      selectValue(hash: object | IRatioMap): object;\n    };\n\n    namespace math {\n      function areEqual(first: number[], second: number[], diff?: number): boolean;\n\n      function cycleRestrict(value: number, min: number, max: number): number;\n\n      function restrict(value: number, min: number, max: number): number;\n    }\n\n    const pixelBounds: {\n      areIntersecting(bounds1: number[][], bounds2: number[][]): boolean;\n\n      containsBounds(outer: number[][], inner: number[][]): boolean;\n\n      containsPoint(bounds: number[][], point: number[][]): boolean;\n\n      fromBounds(sourceBounds: number[][]): number[][];\n\n      fromPoints(points: number[][]): number[][];\n\n      getCenter(bounds: number[][]): number[];\n\n      getIntersection(bounds1: number[][], bounds2: number[][]): number[][] | null;\n\n      getSize(bounds: number[][]): number[];\n    };\n\n    function requireCenterAndZoom(\n      mapType: string | MapType | map.ZoomRange,\n      bounds: number[][],\n      containerSize: number[],\n      params?: {\n        inscribe?: boolean;\n        margin?: number | number[];\n        preciseZoom?: boolean;\n      },\n    ): vow.Promise;\n\n    class Storage {\n      add(key: string, object: object): this;\n\n      get(key: string | object): object | string;\n\n      remove(key: string): object;\n    }\n  }\n\n  namespace vow {\n    class Deferred {\n      promise(): Promise;\n\n      reject(reason: object): void;\n\n      resolve(value: object): void;\n    }\n\n    class Promise {\n      constructor(resolver?: () => void);\n\n      done(\n        onFulfilled?: (...args: any[]) => void,\n        onRejected?: (err?: Error | any) => void,\n        onProgress?: (...args: any[]) => void,\n        ctx?: object,\n      ): void;\n\n      spread(\n        onFulfilled?: (...args: any[]) => void,\n        onRejected?: (err?: Error | any) => void,\n        ctx?: object,\n      ): Promise;\n\n      then(\n        onFulfilled?: (...args: any[]) => void,\n        onRejected?: (err?: Error | any) => void,\n        onProgress?: (...args: any[]) => void,\n        ctx?: object,\n      ): Promise;\n\n      valueOf(): object;\n    }\n\n    function resolve(value: any): any;\n  }\n\n  /* Interfaces */\n\n  interface IBaloon<T> extends IPopup<T>, ICustomizable, IChild<T>, IFreezable {\n    autoPan(): Promise<T>;\n  }\n\n  interface IBalloonManager<T> extends IPopupManager<T> {\n    autoPan(): Promise<T>;\n  }\n\n  interface IBaseGeometry extends IEventEmitter {\n    getBounds(): number[][] | null;\n\n    getType(): string;\n  }\n\n  interface IBaseLineStringGeometry extends IBaseGeometry, ILineStringGeometryAccess {}\n\n  interface IBasePointGeometry extends IBaseGeometry, IPointGeometryAccess {}\n\n  interface IBasePolygonGeometry extends IBaseGeometry, IPolygonGeometryAccess {}\n\n  interface IBehavior extends IChildOnMap, ICustomizable {\n    disable(): void;\n\n    enable(): void;\n\n    isEnabled(): boolean;\n  }\n\n  interface IChild<T> extends IEventEmitter {\n    getParent(): object | null;\n\n    setParent(parent: object | null): this;\n  }\n\n  type IChildOnMap = IChild<IControlParent>;\n\n  interface ICircleGeometry extends ICircleGeometryAccess, IGeometry {}\n\n  interface ICircleGeometryAccess extends IFreezable {\n    contains(position: number[]): boolean;\n\n    getClosest(anchorPosition: number[]): object;\n\n    getCoordinates(): number[] | null;\n\n    getRadius(): number;\n\n    setCoordinates(coordinates: number[] | null): ICircleGeometryAccess;\n\n    setRadius(radius: number): ICircleGeometryAccess;\n  }\n\n  interface ICollection extends IEventEmitter {\n    add(object: object): this;\n\n    getIterator(): IIterator;\n\n    remove(object: object): this;\n  }\n\n  interface IContainerPane extends IPane, IPositioningContext {}\n\n  type IControl = IChildOnMap;\n\n  interface IControlParent extends IParentOnMap {\n    getChildElement(child: IControl): Promise<HTMLElement>;\n  }\n\n  interface ICoordSystem {\n    getDistance(point1: number[], point2: number[]): number;\n\n    solveDirectProblem(startPoint: number[], direction: number[], distance: number): object;\n\n    solveInverseProblem(\n      startPoint: number[],\n      endPoint: number[],\n      reverseDirection?: boolean,\n    ): object;\n  }\n\n  type ICopyrightsAccessor = ICopyrightsProvider;\n\n  interface ICopyrightsProvider extends IEventEmitter {\n    getCopyrights(coords: number[], zoom: number): Promise<Array<string | HTMLElement>>;\n\n    remove(): void;\n\n    setCopyrights(copyrights: string | HTMLElement | Array<string | HTMLElement>): void;\n  }\n\n  interface ICustomizable extends IEventEmitter {\n    options: IOptionManager;\n  }\n\n  interface IDataManager extends IEventEmitter {\n    set(key: object | string, value?: object | number | string | null | undefined): this;\n\n    get(path: string, defaultValue?: object): object;\n  }\n\n  type IDomEventEmitter = IEventEmitter;\n\n  interface IEvent<OriginalEvent = {}, TargetGeometry = {}> {\n    originalEvent: {\n      domEvent: {\n        originalEvent: OriginalEvent;\n      };\n      target: {\n        geometry?: TargetGeometry | undefined;\n      };\n    };\n\n    allowMapEvent(): void;\n\n    callMethod(name: string): void;\n\n    get<T extends OriginalEvent, K extends keyof T = keyof T>(name: K): T[K];\n\n    get(name: 'type'): string;\n\n    get(name: 'objectId'): string | undefined;\n\n    get(name: 'newZoom' | 'oldZoom'): number | undefined;\n\n    get(name: string): any;\n\n    getSourceEvent(): IEvent<OriginalEvent, TargetGeometry> | null;\n\n    isDefaultPrevented(): boolean;\n\n    isImmediatePropagationStopped(): boolean;\n\n    isMapEventAllowed(): boolean;\n\n    isPropagationStopped(): boolean;\n\n    preventDefault(): boolean;\n\n    stopImmediatePropagation(): boolean;\n\n    stopPropagation(): boolean;\n  }\n\n  interface IDomEvent<OriginalEvent = {}, TargetGeometry = {}>\n    extends IEvent<OriginalEvent, TargetGeometry> {\n    getSourceEvent(): IDomEvent<OriginalEvent, TargetGeometry>;\n  }\n\n  interface IEventController {\n    onStartListening?(events: IEventManager, type: string): void;\n\n    onStopListening?(events: IEventManager, type: string): void;\n  }\n\n  interface IEventEmitter {\n    events: IEventManager;\n  }\n\n  interface IEventGroup {\n    add<K extends keyof EventMap>(\n      types: K,\n      callback: (event: EventMap[K] | IEvent) => void,\n      context?: object,\n      priority?: number,\n    ): this;\n\n    add(\n      types: string[][] | string[] | string,\n      callback: (event: object | IEvent) => void,\n      context?: object,\n      priority?: number,\n    ): this;\n\n    remove(\n      types: string[][] | string[] | string,\n      callback: (event: object | IEvent) => void,\n      context?: object,\n      priority?: number,\n    ): this;\n\n    removeAll(): this;\n  }\n\n  interface IEventManager<TargetGeometry = {}> extends IEventTrigger {\n    add<K extends keyof EventMap>(\n      types: K,\n      callback: (event: IEvent<EventMap[K], TargetGeometry>) => void,\n      context?: object,\n      priority?: number,\n    ): this;\n\n    add(\n      types: string[][] | string[] | string,\n      callback: (event: IEvent) => void,\n      context?: object,\n      priority?: number,\n    ): this;\n\n    getParent(): object | null;\n\n    group(): IEventGroup;\n\n    remove(\n      types: string[][] | string[] | string,\n      callback: (event: object | IEvent) => void,\n      context?: object,\n      priority?: number,\n    ): this;\n\n    setParent(parent: object | null): this;\n  }\n\n  interface IEventPane extends IDomEventEmitter, IPane {}\n\n  interface IEventTrigger {\n    fire(type: string, eventObject?: object | IEvent): this;\n  }\n\n  interface IEventWorkflowController extends IEventController {\n    onAfterEventFiring?(events: IEventManager, type: string, event?: IEvent): void;\n\n    onBeforeEventFiring?(events: IEventManager, type: string, event?: IEvent): void;\n  }\n\n  type IExpandableControlLayout = ILayout;\n\n  interface IFreezable {\n    events: IEventManager;\n\n    freeze(): IFreezable;\n\n    isFrozen(): boolean;\n\n    unfreeze(): IFreezable;\n  }\n\n  interface IGeocodeProvider {\n    geocode(\n      request: string,\n      options?: {\n        boundedBy?: number[][];\n        results?: number;\n        skip?: number;\n        strictBounds?: boolean;\n      },\n    ): Promise<object>;\n\n    suggest(\n      request: string,\n      options?: {\n        boundedBy?: number[][];\n        results?: number;\n        strictBounds?: boolean;\n      },\n    ): Promise<object>;\n  }\n\n  function geocode(request: string | number[], options?: IGeocodeOptions): Promise<object>;\n\n  interface IGeocodeOptions {\n    boundedBy?: number[][];\n    json?: boolean;\n    kind?: string;\n    provider?: IGeocodeProvider | string;\n    results?: number;\n    searchCoordOrder?: string;\n    skip?: number;\n    strictBounds?: boolean;\n  }\n\n  interface IGeometry extends IBaseGeometry, ICustomizable {\n    getMap(): Map | null;\n\n    getPixelGeometry(options?: object): IPixelGeometry;\n\n    setMap(map: Map): void;\n  }\n\n  interface IGeometryEditor extends ICustomizable, IEventEmitter {\n    geometry: IGeometry;\n    state: IDataManager;\n\n    startEditing(): void;\n\n    stopEditing(): void;\n  }\n\n  interface IGeometryEditorChildModel extends IGeometryEditorModel {\n    editor: IGeometryEditor;\n    geometry: IBaseGeometry;\n\n    getParent(): IGeometryEditorModel;\n\n    setPixels(pixels: number[]): void;\n  }\n\n  interface IGeometryEditorModel extends IEventEmitter {\n    destroy(): void;\n\n    getPixels(): number[];\n  }\n\n  type IGeometryEditorRootModel = IGeometryEditorModel;\n\n  interface IGeometryJson {\n    type: string;\n    coordinates: number[] | number[][] | number[][][];\n    fillRule?: 'evenOdd' | 'nonZero';\n    radius?: number;\n    [key: string]: any;\n  }\n\n  interface IGeoObject<T = IGeometry>\n    extends IChildOnMap,\n      ICustomizable,\n      IDomEventEmitter,\n      IParentOnMap {\n    geometry: T | null;\n\n    properties: IDataManager;\n\n    state: IDataManager;\n\n    balloon?: geoObject.Balloon;\n\n    getOverlay(): Promise<IOverlay | null>;\n\n    getOverlaySync(): IOverlay | null;\n  }\n\n  interface IGeoObjectCollection extends ICustomizable, IEventEmitter, IParentOnMap {\n    add(child: IGeoObject, index?: number): this;\n\n    each(callback: (object: IGeoObject) => void, context?: object): void;\n\n    get(index: number): IGeoObject;\n\n    getBounds(): number[][] | null;\n\n    getIterator(): IIterator;\n\n    getLength(): number;\n\n    getPixelBounds(): number[][] | null;\n\n    indexOf(object: IGeoObject): number;\n\n    remove(child: IGeoObject): this;\n\n    removeAll(): this;\n\n    set(index: number, child: IGeoObject): this;\n\n    splice(index: number, length: number): this;\n  }\n\n  interface IGeoObjectSequence extends ICustomizable, IEventEmitter, IParentOnMap {\n    each(callback: (geoObject: IGeoObject) => void, context?: object): void;\n\n    get(index: number): IGeoObject;\n\n    getBounds(): number[][] | null;\n\n    getIterator(): IIterator;\n\n    getLength(): number;\n\n    getPixelBounds(): number[][] | null;\n\n    indexOf(geoObject: IGeoObject): number;\n  }\n\n  interface IPromiseProvider {\n    then(onResolve: () => void, onReject: (err?: Error | any) => void): this;\n  }\n\n  type IGeoQuerySource =\n    | IGeoObject\n    | IGeoObject[]\n    | ICollection\n    | ICollection[]\n    | IPromiseProvider\n    | vow.Promise\n    | GeoQueryResult\n    | string\n    | object\n    | object[];\n\n  class GeoQueryResult implements IPromiseProvider {\n    constructor(source: IGeoQuerySource);\n\n    then(onResolve: () => void, onReject?: (err?: Error | any) => void, context?: object): this;\n\n    add(source: IGeoQuerySource): this;\n\n    addEvents(events: string | string[], callback: () => void, context?: object): this;\n\n    addTo(collection: ICollection): this;\n\n    addToMap(map: Map): this;\n\n    applyBoundsToMap(\n      map: Map,\n      options?: {\n        checkZoomRange?: boolean;\n        duration?: number;\n        preciseZoom?: boolean;\n        timingFUnction?: string;\n        useMapMargin?: boolean;\n        zoomMargin?: number | number[];\n      },\n    ): this;\n\n    clusterize(options?: IClustererOptions): Clusterer;\n\n    each(callback: (e: any) => void, context?: object): this;\n\n    get(index: number): IGeoObject;\n\n    getBounds(): number[][] | null;\n\n    getCenter(map?: Map): number[];\n\n    getCentralObject(map: Map): IGeoObject | null;\n\n    getClosestTo(object: IGeoObject | IGeometry | Map | number[] | object | any): IGeoObject | null;\n\n    getExtreme(key: 'top' | 'right' | 'bottom' | 'left'): number;\n\n    getExtremeObject(key: 'top' | 'right' | 'bottom' | 'left'): IGeoObject;\n\n    getGlobalPixelBounds(map: Map): Number[][] | null;\n\n    getGlobalPixelCenter(map: Map): number[];\n\n    getIterator(): IIterator;\n\n    getLength(): number;\n\n    getMaxZoom(map?: Map, options?: { useMapMargin?: boolean }): number;\n\n    getParent(): this | null;\n\n    indexOf(item: IGeoObject | any): number;\n\n    intersect(result: this): this;\n\n    isReady(): boolean;\n\n    map(callback: (e: any) => void, context?: object): this;\n\n    remove(\n      objects: IGeoObject | IGeoObject[] | ICollection | ICollection[] | this | vow.Promise | any,\n    ): this;\n\n    removeEvents(events: string | string[], callback: () => void, context?: object): void;\n\n    removeFrom(collection: ICollection): this;\n\n    removeFromMap(map: Map): this;\n\n    reverse(): this;\n\n    search(condition: string | ((o: object) => boolean)): this;\n\n    searchContaining(\n      object: IGeoObject | IGeometry | Map | number[] | number[][] | object | any,\n    ): this;\n\n    searchInside(object: IGeoObject | IGeometry | Map | any): this;\n\n    searchIntersect(\n      object: IGeoObject | IGeometry | Map | any,\n      options?: { considerOccurance?: boolean },\n    ): this;\n\n    setOptions(key: string | object, value?: any): this;\n\n    setProperties(path: string, value?: any): this;\n\n    slice(begin: number, end?: number): this;\n\n    sort(comparator: string | ((a: any, b: any) => number)): any;\n\n    sortByDistance(\n      object: IGeoObject | IGeometry | Map | number[] | number[][] | object | any,\n    ): this;\n\n    unsetOptions(keys: string | string[]): this;\n\n    unsetProperties(path: string): this;\n  }\n\n  function geoQuery(source: IGeoQuerySource): GeoQueryResult;\n\n  type IHintManager<T> = IPopupManager<T>;\n\n  interface IIterator {\n    getNext(): object | null;\n  }\n\n  interface ILayer extends IChildOnMap, ICustomizable, IEventEmitter {\n    getBrightness?(): number;\n\n    getCopyrights?(coords: number[], zoom: number): Promise<Array<string | HTMLElement>>;\n\n    getZoomRange?(point: number[]): Promise<number[]>;\n  }\n\n  interface ILayout extends IDomEventEmitter {\n    destroy(): void;\n\n    getData(): object;\n\n    getParentElement(): HTMLElement;\n\n    getShape(): IShape | null;\n\n    isEmpty(): boolean;\n\n    setData(data: object): void;\n\n    setParentElement(parent: HTMLElement | null): void;\n  }\n\n  interface ILinearRingGeometryAccess extends IFreezable {\n    contain(position: number): boolean;\n\n    freeze(): IFreezable;\n\n    get(index: number): number[];\n\n    getChildGeometry(index: number): IPointGeometryAccess;\n\n    getClosest(anchorPosition: number[]): object;\n\n    getCoordinates(): number[][];\n\n    getFillRule(): string;\n\n    getLength(): number;\n\n    insert(index: number, coordinates: number[]): ILinearRingGeometryAccess;\n\n    isFrozen(): boolean;\n\n    remove(index: number): number[];\n\n    set(index: number, coordinates: number[]): ILinearRingGeometryAccess;\n\n    setCoordinates(coordinates: number[][]): ILinearRingGeometryAccess;\n\n    setFillRule(fillRule: string): ILinearRingGeometryAccess;\n\n    splice(index: number, number: number): number[][];\n\n    unfreeze(): IFreezable;\n  }\n\n  interface ILineStringGeometry extends IGeometry, ILineStringGeometryAccess {}\n\n  interface ILineStringGeometryAccess extends IFreezable {\n    get(index: number): number[];\n\n    getChildGeometry(index: number): IPointGeometryAccess;\n\n    getClosest(anchorPosition: number[]): object;\n\n    getCoordinates(): number[][];\n\n    getLength(): number;\n\n    insert(index: number, coordinates: number[][]): ILineStringGeometryAccess;\n\n    remove(index: number): number[];\n\n    set(index: number, coordinates: number[]): ILineStringGeometryAccess;\n\n    setCoordinates(coordinates: number[][]): ILineStringGeometryAccess;\n\n    splice(index: number, length: number): number[][];\n  }\n\n  interface IMapAction extends IEventEmitter {\n    begin(mapActionManager: map.action.Manager): void;\n\n    end(): void;\n  }\n\n  interface IMapObjectCollection extends ICollection, ICustomizable, IParentOnMap {}\n\n  interface IMultiRouteModelJson {\n    params?: IMultiRouteParams;\n    referencePoints: IMultiRouteReferencePoint[];\n  }\n\n  interface IMultiRouteParams {\n    avoidTrafficJams?: boolean;\n    boundedBy?: number[][] | null;\n    requestSendInterval?: string | number;\n    results?: number;\n    reverseGeocoding?: boolean;\n    routingMode?: 'auto' | 'masstransit' | 'pedestrian';\n    searchCoordOrder?: string;\n    strictBounds?: boolean;\n    viaIndexes?: number[];\n  }\n\n  type IMultiRouteReferencePoint = string | number[] | geometry.Point;\n\n  interface IOptionManager extends IChild<IOptionManager>, IEventEmitter, IFreezable {\n    get(key: string, defaultValue?: object): any;\n\n    getAll(): object;\n\n    getName(): string;\n\n    getNative(key: string): object;\n\n    resolve(key: string, name?: string): object;\n\n    set(key: object | string, value?: object | number | string | null | undefined): this;\n\n    setName(name: string): void;\n  }\n\n  interface IOverlay extends ICustomizable, IDomEventEmitter {\n    getData(): object;\n\n    getGeometry(): IPixelGeometry;\n\n    getMap(): Map | null;\n\n    getShape(): IShape | null;\n\n    isEmpty(): boolean;\n\n    setData(data: object): void;\n\n    setGeometry(geometry: IPixelGeometry): void;\n\n    setMap(map: Map | null): void;\n  }\n\n  interface IPane extends IEventEmitter {\n    destroy(): void;\n\n    getElement(): HTMLElement;\n\n    getMap(): Map;\n\n    getOverflow(): 'visible' | 'hidden';\n\n    getZIndex(): number;\n  }\n\n  interface IPanorama {\n    getAngularBBox(): number[];\n\n    getConnectionArrows(): IPanoramaConnectionArrow[];\n\n    getConnectionMarkers(): IPanoramaConnectionMarker[];\n\n    getCoordSystem(): ICoordSystem;\n\n    getDefaultDirection(): number[];\n\n    getDefaultSpan(): number[];\n\n    getGraph(): IPanoramaGraph | null;\n\n    getMarkers(): IPanoramaMarker[];\n\n    getName(): string;\n\n    getPosition(): number[];\n\n    getTileLevels(): IPanoramaTileLevel[];\n\n    getTileSize(): number[];\n  }\n\n  interface IPanoramaConnection {\n    getConnectedPanorama(): Promise<IPanorama>;\n  }\n\n  interface IPanoramaConnectionArrow extends IPanoramaConnection {\n    properties: data.Manager;\n\n    getDirection(): number[];\n\n    getPanorama(): IPanorama;\n  }\n\n  interface IPanoramaConnectionMarker extends IPanoramaConnection, IPanoramaMarker {}\n\n  interface IPanoramaGraph {\n    getEdges(): IPanoramaGraphEdge[];\n\n    getNodes(): IPanoramaGraphEdge[];\n\n    getPanorama(): IPanorama;\n  }\n\n  interface IPanoramaGraphEdge {\n    getEndNodes(): IPanoramaGraphNode[];\n  }\n\n  interface IPanoramaGraphNode {\n    getConnectedPanorama(): Promise<IPanorama>;\n  }\n\n  interface IPanoramaMarker {\n    properties: data.Manager;\n\n    getIconSet(): Promise<IPanoramaMarkerIconSet>;\n\n    getPanorama(): IPanorama;\n\n    getPosition(): number[];\n  }\n\n  interface IPanoramaMarkerIcon {\n    image: HTMLCanvasElement | HTMLImageElement;\n    offset: number[];\n  }\n\n  interface IPanoramaMarkerIconSet {\n    default: IPanoramaMarkerIcon | null;\n    expanded: IPanoramaMarkerIcon | null;\n    expandedHovered: IPanoramaMarkerIcon | null;\n    hovered: IPanoramaMarkerIcon | null;\n  }\n\n  interface IPanoramaTileLevel {\n    getImageSize(): number[];\n\n    getTileUrl(x: number, y: number): string;\n  }\n\n  interface IParentOnMap {\n    getMap(): Map;\n  }\n\n  interface IPixelCircleGeometry extends IPixelGeometry {\n    getCoordinates(): number[];\n\n    getRadius(): number;\n  }\n\n  interface IPixelLineStringGeometry extends IPixelGeometry {\n    getClosest(anchorPosition: number[]): object;\n\n    getCoordinates(): number[][];\n\n    getLength(): number;\n  }\n\n  interface IPixelPointGeometry extends IPixelGeometry {\n    getCoordinates(): number[];\n  }\n\n  interface IPixelMultiLineGeometry extends IPixelGeometry {\n    getClosest(anchorPosition: number[]): object;\n\n    getCoordinates(): number[][][];\n\n    getLength(): number;\n  }\n\n  interface IPixelMultiPolygonGeometry extends IPixelGeometry {\n    contains(position: number[]): boolean;\n\n    getClosest(anchorPosition: number[]): object;\n\n    getCoordinates(): number[][][][];\n\n    getFillRule(): 'evenOdd' | 'nonZero';\n\n    getLength(): number;\n  }\n\n  interface IPixelPolygonGeometry extends IPixelGeometry {\n    contains(position: number[]): boolean;\n\n    getClosest(anchorPosition: number[]): object;\n\n    getCoordinates(): number[][][];\n\n    getFillRule(): 'evenOdd' | 'nonZero';\n\n    getLength(): number;\n  }\n\n  interface IPixelRectangleGeometry extends IPixelGeometry {\n    getClosest(anchorPosition: number[]): object;\n\n    getCoordinates(): number[][];\n  }\n\n  interface IPixelGeometry extends IBaseGeometry {\n    equals(geometry: IPixelGeometry): boolean;\n\n    getMetaData(): object;\n\n    scale(factor: number): IPixelGeometry;\n\n    shift(offset: number[]): IPixelGeometry;\n  }\n\n  interface IPointGeometry extends IGeometry, IPointGeometryAccess {}\n\n  interface IPointGeometryAccess {\n    getCoordinates(): number[] | null;\n\n    setCoordinates(coordinates: number[] | null): this;\n  }\n\n  interface IPolygonGeometry extends IGeometry, IPolygonGeometryAccess {}\n\n  interface IPolygonGeometryAccess extends IFreezable {\n    contains(position: number[]): boolean;\n\n    get(index: number): number[][];\n\n    getChildGeometry(index: number): ILinearRingGeometryAccess;\n\n    getClosest(anchorPosition: number[]): object;\n\n    getCoordinates(): number[][][];\n\n    getFillRule(): string;\n\n    getLength(): number;\n\n    insert(index: number, path: number[][]): IPolygonGeometryAccess;\n\n    remove(index: number): ILinearRingGeometryAccess;\n\n    set(index: number, path: number[][]): IPolygonGeometryAccess;\n\n    setCoordinates(coordinates: number[][][]): IPolygonGeometryAccess;\n\n    setFillRule(fillRule: string): IPolygonGeometryAccess;\n\n    splice(index: number, number: number): ILinearRingGeometryAccess[];\n  }\n\n  interface IPopup<T> extends ICustomizable, IEventEmitter {\n    close(force?: boolean): Promise<T>;\n\n    getData(): object;\n\n    getOverlay(): Promise<IOverlay>;\n\n    getOverlaySync(): IOverlay;\n\n    getPosition(): number[];\n\n    isOpen(): boolean;\n\n    open(position: number[], data: object | string | HTMLElement): Promise<T>;\n\n    setData(data: object | string | HTMLElement): Promise<T>;\n\n    setPosition(position: number[]): Promise<T>;\n  }\n\n  interface IPopupManager<T> extends IEventEmitter {\n    close(force?: boolean): Promise<T>;\n\n    destroy(): void;\n\n    getData(): object | null;\n\n    getOptions(): IOptionManager | null;\n\n    getOverlay(): Promise<IOverlay | null>;\n\n    getOverlaySync(): IOverlay | null;\n\n    getPosition(): number[] | null;\n\n    isOpen(): boolean;\n\n    open(position?: number[], data?: object | string | HTMLElement, options?: object): Promise<T>;\n\n    setData(data: object | string | HTMLElement): Promise<T>;\n\n    setOptions(options: object): Promise<T>;\n\n    setPosition(position: number[]): Promise<T>;\n  }\n\n  interface IPositioningContext {\n    fromClientPixels(clientPixelPoint: number[]): number[];\n\n    getZoom(): number;\n\n    toClientPixels(globalPixelPoint: number[]): number[];\n  }\n\n  interface IProjection {\n    fromGlobalPixels(globalPixelPoint: number[], zoom: number): number[];\n\n    getCoordSystem(): ICoordSystem;\n\n    isCycled(): boolean[];\n\n    toGlobalPixels(coordPoint: number[], zoom: number): number[];\n  }\n\n  interface IRoutePanel {\n    options: IOptionManager;\n\n    state: IDataManager;\n\n    enable(): void;\n\n    geolocate(name: string): Promise<{ geoObjects: GeoObjectCollection }>;\n\n    getRoute(): multiRouter.MultiRoute;\n\n    getRouteAsync(): Promise<multiRouter.MultiRoute>;\n\n    isEnable(): boolean;\n\n    switchPoints(): void;\n  }\n\n  type ISearchControlLayout = IExpandableControlLayout;\n\n  interface ISelectableControl extends IControl {\n    deselect(): void;\n\n    disable(): void;\n\n    enable(): void;\n\n    isEnabled(): boolean;\n\n    isSelected(): boolean;\n\n    select(): void;\n  }\n\n  type ISelectableControlLayout = ILayout;\n\n  interface IShape {\n    contains(position: number[]): boolean;\n\n    equals(shape: IShape): boolean;\n\n    getBounds(): number[][] | null;\n\n    getGeometry(): IPixelGeometry;\n\n    getType(): string;\n\n    scale(factor: number): IShape;\n\n    shift(offset: number[]): IShape;\n  }\n\n  class Monitor {\n    constructor(dataManager: IDataManager | IOptionManager);\n\n    add(\n      name: string[] | string,\n      changeCallback: (event: object | IEvent) => void,\n      context?: any,\n      params?: any,\n    ): Monitor;\n\n    forceChange(): Monitor;\n\n    get(name: string): any;\n\n    remove(name: string): Monitor;\n\n    removeAll(): Monitor;\n  }\n\n  class ObjectManager implements ICustomizable, IEventEmitter, IGeoObject, IParentOnMap {\n    constructor(options: IObjectManagerOptions);\n\n    clusters: objectManager.ClusterCollection;\n\n    events: IEventManager;\n\n    geometry: IGeometry | null;\n\n    objects: objectManager.ObjectCollection;\n\n    options: IOptionManager;\n\n    properties: IDataManager;\n\n    state: IDataManager;\n\n    add(objects: object | object[] | string): this;\n\n    getBounds(): number[][] | null;\n\n    getFilter(): string | ((object: object | string) => boolean) | null;\n\n    getMap(): Map;\n\n    getObjectState(id: any): {\n      found: boolean;\n      isShown: boolean;\n      cluster?: object;\n      isClustered: boolean;\n      isFilteredOut: boolean;\n    };\n\n    getOverlay(): Promise<IOverlay | null>;\n\n    getOverlaySync(): IOverlay | null;\n\n    getParent(): IParentOnMap | null;\n\n    getPixelBounds(): number[][] | null;\n\n    remove(objects: object | object[] | string): this;\n\n    removeAll(): this;\n\n    setFilter(filterFunction: (object: object | string) => boolean): void;\n\n    setParent(parent: IParentOnMap | null): this;\n  }\n\n  interface IObjectManagerOptions\n    extends IClustererOptionsInject,\n      IClusterPlacemarkOptionsWithClusterPrefix {\n    clusterize?: boolean | undefined;\n    syncOverlayInit?: boolean | undefined;\n    viewportMargin?: number[] | number | undefined;\n  }\n\n  namespace objectManager {\n    class Balloon implements Omit<IBalloonManager<map.Balloon>, 'isOpen' | 'open'> {\n      constructor(collection: object);\n\n      events: IEventManager;\n\n      autoPan(): Promise<ymaps.Balloon>;\n\n      close(force?: boolean): Promise<ymaps.Balloon>;\n\n      destroy(): void;\n\n      getData(): object | null;\n\n      getOptions(): IOptionManager | null;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getPosition(): number[] | null;\n\n      isOpen(id: any): boolean;\n\n      open(objectId: any, anchorPixelPosition?: boolean): Promise<ymaps.Balloon>;\n\n      setData(objectData: object | string | HTMLElement): Promise<ymaps.Balloon>;\n\n      setOptions(options: object): Promise<ymaps.Balloon>;\n\n      setPosition(position: number[]): Promise<ymaps.Balloon>;\n    }\n\n    class ClusterCollection implements ICustomizable, IEventEmitter {\n      balloon: objectManager.Balloon;\n\n      events: IEventManager;\n\n      hint: objectManager.Hint;\n\n      options: option.Manager;\n\n      overlays: objectManager.OverlayCollection;\n\n      state: data.Manager;\n\n      each(callback: (cluster: object) => void, context?: object): void;\n\n      getAll(): object[];\n\n      getById(id: string): object | null;\n\n      getIterator(): IIterator;\n\n      getLength(): number;\n\n      getObjectManager(): ObjectManager;\n\n      setClusterOptions(objectId: string, options: object): this;\n    }\n\n    class Hint implements Omit<IHintManager<map.Hint>, 'isOpen' | 'open'> {\n      constructor(collection: object);\n\n      events: IEventManager;\n\n      close(force?: boolean): Promise<map.Hint>;\n\n      destroy(): void;\n\n      getData(): object | null;\n\n      getOptions(): IOptionManager | null;\n\n      getOverlay(): Promise<IOverlay | null>;\n\n      getOverlaySync(): IOverlay | null;\n\n      getPosition(): number[] | null;\n\n      isOpen(id: any): boolean;\n\n      open(objectId: any, position?: number[]): Promise<map.Hint>;\n\n      setData(data: object | string | HTMLElement): Promise<map.Hint>;\n\n      setOptions(options: object): Promise<map.Hint>;\n\n      setPosition(position: number[]): Promise<map.Hint>;\n    }\n\n    class ObjectCollection implements ICollection, ICustomizable {\n      balloon: objectManager.Balloon;\n\n      events: IEventManager;\n\n      hint: objectManager.Hint;\n\n      options: option.Manager;\n\n      overlays: objectManager.OverlayCollection;\n\n      add(object: object): this;\n\n      each(callback: (object: object) => void, context?: object): void;\n\n      getAll(): object[];\n\n      getById(id: number): object | null;\n\n      getIterator(): IIterator;\n\n      getLength(): number;\n\n      getObjectManager(): ObjectManager;\n\n      remove(data: object | object[] | string): this;\n\n      removeAll(): objectManager.ObjectCollection;\n\n      setObjectOptions(objectId: any, options: object): ObjectCollection;\n    }\n\n    class OverlayCollection implements ICustomizable, IEventEmitter {\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      each(callback: (overlay: IOverlay) => void, context?: object): void;\n\n      getAll(): object[];\n\n      getById(id: number): IOverlay | null;\n\n      getId(overlay: IOverlay): number | null;\n\n      getIterator(): IIterator;\n\n      getLength(): number;\n    }\n  }\n\n  namespace modules {\n    function define(\n      module: string,\n      depends?: string[],\n      resolveCallback?: ResolveCallbackFunction,\n      context?: object,\n    ): typeof modules;\n\n    function define(\n      module: string,\n      resolveCallback?: ResolveCallbackFunction,\n      context?: object,\n    ): typeof modules;\n\n    function isDefined(module: string): boolean;\n\n    function require(\n      modules: string | string[],\n      successCallback?: (...args: any[]) => void,\n      errorCallback?: (error: any) => void,\n      context?: object,\n    ): vow.Promise;\n  }\n\n  interface IHotspotObjectSource extends ICustomizable, IEventEmitter {\n    cancelLastRequest(): void;\n\n    requestObjects(\n      layer: hotspot.Layer,\n      tileNumber: number[],\n      zoom: number,\n      callback: () => void,\n    ): void;\n  }\n\n  interface IHotspotLayerOptions\n    extends IBalloonOptionsWithBalloonPrefix,\n      IHintOptionsWithHintPrefix {\n    cursor?: string;\n    dontChangeCursor?: boolean;\n    hasBalloon?: boolean;\n    hasHint?: boolean;\n    interactivityModel?: InteractivityModelKey;\n    openBalloonOnClick?: boolean;\n    openEmptyBalloon?: boolean;\n    openEmptyHint?: boolean;\n    openHintOnHover?: boolean;\n    pane?: IEventPane;\n    showEmptyBalloon?: boolean;\n    zIndex?: number;\n  }\n\n  interface IHotspotLayerObject extends ICustomizable, IDomEventEmitter {\n    getGeometry(): object;\n\n    getHotspot(): IHotspot;\n\n    getId(): number;\n\n    getProperties(): object;\n\n    setGeometry(geometry: object): void;\n\n    setId(id: number): void;\n\n    setProperties(properties: object): void;\n  }\n\n  namespace hotspot {\n    namespace layer {\n      namespace addon {\n        const balloon: {\n          get(layer: hotspot.Layer): IPopupManager<Balloon>;\n        };\n\n        const hint: {\n          get(layer: hotspot.Layer): IPopupManager<Hint>;\n        };\n      }\n\n      class Balloon implements IBalloonManager<Balloon> {\n        constructor(hotspotLayer: object);\n\n        events: IEventManager;\n\n        autoPan(): Promise<Balloon>;\n\n        close(force?: boolean): Promise<Balloon>;\n\n        destroy(): void;\n\n        getData(): object | null;\n\n        getOptions(): IOptionManager | null;\n\n        getOverlay(): Promise<IOverlay | null>;\n\n        getOverlaySync(): IOverlay | null;\n\n        getPosition(): number[] | null;\n\n        isOpen(): boolean;\n\n        open(position?: number[], data?: object, options?: object): Promise<Balloon>;\n\n        setData(data: object | string | HTMLElement): Promise<Balloon>;\n\n        setOptions(options: object): Promise<Balloon>;\n\n        setPosition(position: number[]): Promise<Balloon>;\n      }\n\n      class Hint implements IHintManager<Hint> {\n        constructor(hotspotLayer: object);\n\n        events: IEventManager;\n\n        close(force?: boolean): Promise<Hint>;\n\n        destroy(): void;\n\n        getData(): object | null;\n\n        getOptions(): IOptionManager | null;\n\n        getOverlay(): Promise<IOverlay | null>;\n\n        getOverlaySync(): IOverlay | null;\n\n        getPosition(): number[] | null;\n\n        isOpen(): boolean;\n\n        open(position?: number[], data?: object, options?: object): Promise<Hint>;\n\n        setData(data: object | string | HTMLElement): Promise<Hint>;\n\n        setOptions(options: object): Promise<Hint>;\n\n        setPosition(position: number[]): Promise<Hint>;\n      }\n\n      class Object implements IHotspotLayerObject {\n        constructor(shape: IShape, feature: object, options: object);\n\n        events: IEventManager;\n\n        options: IOptionManager;\n\n        getGeometry(): object;\n\n        getHotspot(): IHotspot;\n\n        getId(): number;\n\n        getProperties(): object;\n\n        setGeometry(geometry: object): void;\n\n        setId(id: number): void;\n\n        setProperties(properties: object): void;\n      }\n    }\n\n    class Layer implements IChildOnMap, ICustomizable {\n      constructor(objectSource: IHotspotObjectSource, options: IHotspotLayerOptions);\n\n      balloon: hotspot.layer.Balloon;\n\n      events: IEventManager;\n\n      hint: hotspot.layer.Balloon;\n\n      options: IOptionManager;\n\n      getMap(): Map;\n\n      getObjectInPosition(coords: number[]): vow.Promise;\n\n      getObjectsInPosition(coords: number[]): vow.Promise;\n\n      getObjectSource(): ObjectSource;\n\n      getParent(): IParentOnMap | null;\n\n      setParent(parent: IParentOnMap | null): this;\n\n      update(): void;\n    }\n\n    class ObjectSource implements IHotspotObjectSource {\n      constructor(\n        tileUrlTemplate: string | ((tileNumber: number[], tileZoom: number) => string),\n        keyTemplate?: string | ((tileNumber: number[], tileZoom: number) => string),\n        options?: {\n          bounds?: number[][];\n          maxZoom?: number;\n          minZoom?: number;\n          noCache?: boolean;\n        },\n      );\n\n      events: IEventManager;\n\n      options: IOptionManager;\n\n      cancelLastRequest(): void;\n\n      getKey(tileNumber: number[], zoom: number): string;\n\n      getKeyTemplate(): string;\n\n      getTileUrl(tileNumber: number[], zoom: number): string;\n\n      getTileUrlTemplate(): string;\n\n      parseResponse(\n        layer: hotspot.Layer,\n        res: object,\n        callback: () => void,\n        tileNumber: number[],\n        zoom: number,\n      ): void;\n\n      requestObjects(\n        layer: hotspot.Layer,\n        tileNumber: number[],\n        zoom: number,\n        callback: () => void,\n      ): void;\n\n      restrict(layer: hotspot.Layer, tileNumber: number[], zoom: number): boolean;\n\n      setKeyTemplate(template: string): void;\n\n      setTileUrlTemplate(template: string): void;\n    }\n  }\n\n  class Hotspot implements IHotspot {\n    constructor(shape: IShape, zIndex?: number);\n\n    events: IEventManager;\n  }\n\n  interface IHotspot extends IDomEventEmitter {\n    events: IEventManager;\n  }\n\n  namespace geolocation {\n    interface IGeolocationOptions {\n      autoReverseGeocode?: boolean;\n      mapStateAutoApply?: boolean;\n      provider?: string;\n      timeout?: number;\n      useMapMargin?: boolean;\n    }\n\n    function get(options?: IGeolocationOptions): Promise<{ geoObjects: GeoObjectCollection }>;\n  }\n\n  interface ISuggestProvider {\n    suggest(\n      request: string,\n      options?: {\n        boundedBy?: number[][];\n        results?: number;\n      },\n    ): Promise<object>;\n  }\n\n  interface ISuggestViewOptions {\n    boundedBy?: number[][];\n    container?: HTMLElement;\n    layout?: string | any;\n    offset?: number[];\n    provider?: string | ISuggestProvider;\n    results?: number;\n    width?: number;\n    zIndex?: number;\n  }\n\n  class SuggestView implements ICustomizable, IEventEmitter {\n    constructor(element: HTMLElement | string, options?: ISuggestViewOptions);\n\n    events: IEventManager;\n\n    options: IOptionManager;\n\n    state: data.Manager;\n\n    destroy(): void;\n  }\n\n  interface ITile extends IEventEmitter {\n    events: IEventManager;\n\n    destroy(): void;\n\n    isReady(): boolean;\n  }\n\n  interface ICanvasTile extends ITile {\n    events: IEventManager;\n\n    destroy(): void;\n\n    isReady(): boolean;\n\n    renderAt(context: any, canvasSize: number[], bounds: number[][], animate?: boolean): void;\n  }\n\n  interface IDomTile extends ITile {\n    events: IEventManager;\n\n    destroy(): void;\n\n    isReady(): boolean;\n\n    renderAt(context: HTMLElement, clientBounds: number[][], animate?: boolean): void;\n  }\n\n  namespace layer {\n    const storage: util.Storage;\n\n    namespace tile {\n      interface ITileOptions {\n        notFoundTile?: string | null;\n        tileAnimationDuration?: number;\n      }\n\n      interface ITileRenderOptions {\n        tileNumber?: number[];\n        tileZoom?: number;\n      }\n\n      class CanvasTile implements ICanvasTile {\n        constructor(url: string, options?: ITileOptions, renderOptions?: ITileRenderOptions);\n\n        events: IEventManager;\n\n        destroy(): void;\n\n        isReady(): boolean;\n\n        renderAt(context: any, canvasSize: number[], bounds: number[][], animate?: boolean): void;\n      }\n\n      class DomTile implements IDomTile {\n        constructor(url: string, options?: ITileOptions, renderOptions?: ITileRenderOptions);\n\n        events: IEventManager;\n\n        destroy(): void;\n\n        isReady(): boolean;\n\n        renderAt(context: HTMLElement, clientBounds: number[][], animate?: boolean): void;\n      }\n    }\n\n    namespace tileContainer {\n      interface CanvasContainerOptions {\n        notFoundTile?: string | null;\n        tileClass?: ICanvasTile;\n        tileTransparent?: boolean;\n      }\n\n      class CanvasContainer implements IChildOnMap {\n        constructor(layer: ILayer, options?: CanvasContainerOptions);\n\n        events: IEventManager;\n\n        getMap(): Map;\n\n        getParent(): object | null;\n\n        getTile(tileNumber: number[], tileZoom: number, priority: number): ICanvasTile;\n\n        setParent(parent: object | null): this;\n      }\n\n      interface DomContainerOptions {\n        notFoundTile?: string | null;\n        tileClass?: IDomTile;\n        tileTransparent?: boolean;\n      }\n\n      class DomContainer implements IChildOnMap {\n        constructor(layer: ILayer, options?: DomContainerOptions);\n\n        events: IEventManager;\n\n        getMap(): Map;\n\n        getParent(): object | null;\n\n        getTile(tileNumber: number[], tileZoom: number, priority: number): ICanvasTile;\n\n        setParent(parent: object | null): this;\n      }\n    }\n  }\n\n  namespace mapType {\n    const storage: util.Storage;\n  }\n\n  namespace projection {\n    class Cartesian implements IProjection {\n      constructor(bounds: number[][], cycled?: boolean[], scale?: number | number[]);\n\n      fromGlobalPixels(globalPixelPoint: number[], zoom: number): number[];\n\n      getCoordSystem(): ICoordSystem;\n\n      isCycled(): boolean[];\n\n      toGlobalPixels(coordPoint: number[], zoom: number): number[];\n    }\n\n    const sphericalMercator: IProjection;\n\n    const wgs84Mercator: IProjection;\n  }\n}\n","import { DOCUMENT } from '@angular/common';\nimport { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\nimport { from, fromEvent, merge, Observable, throwError } from 'rxjs';\nimport { map, switchMap, take } from 'rxjs/operators';\n\n/**\n * Injection token to specify configuration.\n */\nexport const YA_CONFIG = new InjectionToken<YaConfig>('YA_CONFIG');\n\n/**\n * API loading parameters.\n */\nexport interface YaConfig {\n  /**\n   * API key. You can get a key in the developer's dashboard.\n   */\n  apikey?: string;\n  /**\n   * Locale.\n   */\n  lang?: 'ru_RU' | 'en_US' | 'en_RU' | 'ru_UA' | 'uk_UA' | 'tr_TR';\n  /**\n   * The order for setting geographical coordinates in API functions that accept longitude-latitude input.\n   */\n  coordorder?: 'latlong' | 'longlat';\n  /**\n   * List of modules to load.\n   */\n  load?: string;\n  /**\n   * API loading mode.\n   */\n  mode?: 'release' | 'debug';\n  /**\n   * Use commercial version of the API.\n   */\n  enterprise?: boolean;\n  /**\n   * Version number of the API.\n   */\n  version?: string;\n}\n\n/**\n * The `YaApiLoader` service handles loading of Yandex.Maps API.\n *\n * @example\n * ```ts\n * import { YaApiLoaderService } from 'angular8-yandex-maps';\n *\n * export class AppComponent {\n *   constructor(private yaApiLoaderService: YaApiLoaderService) {\n *     this.yaApiLoaderService.load()\n *       .subscribe(v => console.log(v))\n *   }\n * }\n *```\n *\n * @dynamic\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class YaApiLoaderService {\n  private readonly _config: YaConfig;\n\n  private readonly _defaultConfig: YaConfig = { lang: 'ru_RU' };\n\n  private _script: HTMLScriptElement;\n\n  constructor(\n    @Optional() @Inject(YA_CONFIG) config: YaConfig | null,\n    @Inject(DOCUMENT) private readonly _document: Document,\n  ) {\n    this._config = {\n      ...this._defaultConfig,\n      ...config,\n    };\n  }\n\n  /**\n   * Loads Yandex.Maps API.\n   */\n  load(): Observable<typeof ymaps> {\n    if (window.ymaps) {\n      return from(ymaps.ready()).pipe(map(() => ymaps));\n    }\n\n    if (!this._script) {\n      const script = this._document.createElement('script');\n\n      script.type = 'text/javascript';\n      script.src = this._getScriptSource(this._config);\n      script.id = 'yandexMapsApiScript';\n      script.async = true;\n      script.defer = true;\n\n      this._script = this._document.body.appendChild(script);\n    }\n\n    const load = fromEvent(this._script, 'load').pipe(\n      switchMap(() => from(ymaps.ready()).pipe(map(() => ymaps))),\n    );\n\n    const error = fromEvent(this._script, 'error').pipe(switchMap((e) => throwError(e)));\n\n    return merge(load, error).pipe(take(1));\n  }\n\n  /**\n   * Returns script source by config.\n   * @param config config with parameters that will be added in source\n   * @example\n   * // returns 'https://api-maps.yandex.ru/2.1/?apikey=658f67a2-fd77-42e9-b99e-2bd48c4ccad4&lang=en_US'\n   * getScriptSource({ apikey: '658f67a2-fd77-42e9-b99e-2bd48c4ccad4', lang: 'en_US' })\n   */\n  private _getScriptSource(config: YaConfig): string {\n    const { enterprise, version = '2.1', ...rest } = config;\n    const params = this._convertConfigIntoQueryParams(rest);\n\n    return `https://${enterprise ? 'enterprise.' : ''}api-maps.yandex.ru/${version}/?${params}`;\n  }\n\n  /**\n   * Converts a config into a query string parameters.\n   * @param config object for converting\n   * @example\n   * // returns \"lang=ru_RU&apikey=XXX\"\n   * convertIntoQueryParams({ lang: 'ru_RU', apikey: 'XXX' })\n   */\n  private _convertConfigIntoQueryParams(config: YaConfig): string {\n    return Object.entries(config)\n      .map(([key, value]) => `${key}=${value}`)\n      .join('&');\n  }\n}\n","/**\n * Copied from angular/components/google-maps and edited for Yandex.Maps API.\n * {@link https://github.com/angular/components/blob/master/src/google-maps/map-event-manager.ts}\n */\n\nimport { NgZone } from '@angular/core';\nimport { BehaviorSubject, Observable, Subscriber } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { YaEvent } from './typings/ya-event';\n\n/**\n * @internal\n */\ntype EventManagerTarget = {\n  events: ymaps.IEventManager;\n};\n\n/**\n * Manages event on a Yandex.Maps object, ensuring that events are added only when necessary.\n * @internal\n */\nexport class EventManager {\n  /**\n   * Listeners that were added before the target was set.\n   */\n  private _pending: {\n    observable: Observable<any>;\n    observer: Subscriber<any>;\n  }[] = [];\n\n  private _listeners: {\n    name: string;\n    callback: (e: ymaps.Event) => void;\n    manager: ymaps.IEventManager;\n  }[] = [];\n\n  private readonly _targetStream = new BehaviorSubject<EventManagerTarget | undefined>(undefined);\n\n  constructor(private readonly _ngZone: NgZone) {}\n\n  /**\n   * Gets an observable that adds an event listener to the map when a consumer subscribes to it.\n   * @param name\n   */\n  getLazyEmitter(name: string): Observable<YaEvent> {\n    return this._targetStream.pipe(\n      switchMap((target) => {\n        const observable = new Observable<YaEvent>((observer) => {\n          // If the target hasn't been initialized yet, cache the observer so it can be added later.\n          if (!target) {\n            this._pending.push({ observable, observer });\n            return undefined;\n          }\n\n          const callback = (event: ymaps.Event) => {\n            const e = {\n              event,\n              target,\n              ymaps,\n            };\n\n            this._ngZone.run(() => observer.next(e));\n          };\n\n          const listener = target.events.add(name, callback);\n          this._listeners.push({ name, callback, manager: listener });\n\n          // Unsubscribe function\n          return () => listener.remove(name, callback as any);\n        });\n\n        return observable;\n      }),\n    );\n  }\n\n  /**\n   * Sets the current target that the manager should bind events to.\n   * @param target\n   */\n  setTarget(target: EventManagerTarget): void {\n    const currentTarget = this._targetStream.value;\n\n    if (target === currentTarget) {\n      return;\n    }\n\n    // Clear the listeners from the pre-existing target.\n    if (currentTarget) {\n      this._clearListeners();\n      this._pending = [];\n    }\n\n    this._targetStream.next(target);\n\n    // Add the listeners that were bound before the map was initialized.\n    this._pending.forEach((subscriber) => subscriber.observable.subscribe(subscriber.observer));\n\n    this._pending = [];\n  }\n\n  /**\n   * Destroys the manager and clears the event listeners.\n   */\n  destroy(): void {\n    this._clearListeners();\n    this._pending = [];\n    this._targetStream.complete();\n  }\n\n  /**\n   * Clears all currently-registered event listeners.\n   */\n  private _clearListeners() {\n    this._listeners.forEach((listener) => {\n      const { name, callback, manager } = listener;\n      manager.remove(name, callback as any);\n    });\n\n    this._listeners = [];\n  }\n}\n","/**\n * Generates a random string based on Date in hexadecimal numeral system\n * @example f175517fa4f3\n * @internal\n */\nexport const generateRandomId = (): string => `f${Number(new Date()).toString(16)}`;\n","import {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Output,\n  PLATFORM_ID,\n  SimpleChanges,\n  ViewChild,\n} from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { BehaviorSubject, Observable, Subscription } from 'rxjs';\nimport { EventManager } from '../../event-manager';\nimport { generateRandomId } from '../../utils/generate-random-id';\nimport { YaApiLoaderService } from '../../services/ya-api-loader/ya-api-loader.service';\nimport { YaReadyEvent } from '../../typings/ya-ready-event';\nimport { YaEvent } from '../../typings/ya-event';\n\n/**\n * The `ya-map` component wraps `ymaps.Map` class from the Yandex.Maps API.\n * You can configure the map via the component's inputs.\n * Events can be bound using the outputs of the component.\n *\n * <example-url>https://stackblitz.com/edit/map-onload-event?embed=1</example-url>\n *\n * @example\n * ```html\n * <ya-map\n *   [center]=\"[55.751952, 37.600739]\"\n *   [state]=\"{type: 'yandex#satellite'}\"\n * ></ya-map>\n * ```\n */\n@Component({\n  selector: 'ya-map',\n  template: '<div #container></div>',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class YaMapComponent implements AfterViewInit, OnChanges, OnDestroy {\n  @ViewChild('container') container: ElementRef;\n\n  private readonly _sub = new Subscription();\n\n  private readonly _eventManager = new EventManager(this._ngZone);\n\n  map$ = new BehaviorSubject<ymaps.Map | undefined>(undefined);\n\n  isBrowser: boolean;\n\n  /**\n   * Map center geocoordinates. Default is [0, 0].\n   * Shorthand for [state]=\"{ center: [0, 0] }\".\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/Map.html#Map__param-state.center}\n   */\n  @Input() center: number[];\n\n  /**\n   * Map zoom level. Default level is 10.\n   * Shorthand for [state]=\"{ zoom: 10 }\".\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/Map.html#Map__param-state.zoom}\n   */\n  @Input() zoom: number;\n\n  /**\n   * States for the map.\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/Map.html#Mapparam-state}\n   */\n  @Input() state: ymaps.IMapState;\n\n  /**\n   * Options for the map.\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/Map.html#Mapparam-options}\n   */\n  @Input() options: ymaps.IMapOptions;\n\n  /**\n   * Map instance is created.\n   */\n  @Output() ready: EventEmitter<YaReadyEvent<ymaps.Map>> = new EventEmitter<\n    YaReadyEvent<ymaps.Map>\n  >();\n\n  /**\n   * The start of a new smooth map movement.\n   */\n  @Output() actionbegin: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('actionbegin');\n\n  /**\n   * Event that occurs when an action step was prematurely stopped.\n   */\n  @Output() actionbreak: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('actionbreak');\n\n  /**\n   * The end of smooth map movement.\n   */\n  @Output() actionend: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('actionend');\n\n  /**\n   * The start of a new step of smooth movement.\n   */\n  @Output() actiontick: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('actiontick');\n\n  /**\n   * The end of performing a step of smooth movement.\n   */\n  @Output() actiontickcomplete: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('actiontickcomplete');\n\n  /**\n   * Closing the balloon.\n   */\n  @Output() balloonclose: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('balloonclose');\n\n  /**\n   * Opening a balloon on a map.\n   */\n  @Output() balloonopen: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('balloonopen');\n\n  /**\n   * Event for a change to the map viewport.\n   */\n  @Output() boundschange: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('boundschange');\n\n  /**\n   * Single left-click on the object.\n   */\n  @Output() yaclick: Observable<YaEvent<ymaps.Map>> = this._eventManager.getLazyEmitter('click');\n\n  /**\n   * Calls the element's context menu.\n   */\n  @Output() yacontextmenu: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('contextmenu');\n\n  /**\n   * Double left-click on the object.\n   */\n  @Output() yadblclick: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('dblclick');\n\n  /**\n   * The map was destroyed.\n   */\n  @Output() destroy: Observable<YaEvent<ymaps.Map>> = this._eventManager.getLazyEmitter('destroy');\n\n  /**\n   * Closing the hint.\n   */\n  @Output() hintclose: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('hintclose');\n\n  /**\n   * Opening a hint on a map.\n   */\n  @Output() hintopen: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('hintopen');\n\n  /**\n   * Map margins changed.\n   */\n  @Output() marginchange: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('marginchange');\n\n  /**\n   * Pressing the mouse button over the object.\n   */\n  @Output() yamousedown: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('mousedown');\n\n  /**\n   * Pointing the cursor at the object.\n   */\n  @Output() yamouseenter: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('mouseenter');\n\n  /**\n   * Moving the cursor off of the object.\n   */\n  @Output() yamouseleave: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('mouseleave');\n\n  /**\n   * Moving the cursor over the object.\n   */\n  @Output() yamousemove: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('mousemove');\n\n  /**\n   * Letting go of the mouse button over an object.\n   */\n  @Output() yamouseup: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('mouseup');\n\n  /**\n   * End of multitouch.\n   */\n  @Output() multitouchend: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('multitouchend');\n\n  /**\n   * Repeating event during multitouch.\n   */\n  @Output() multitouchmove: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('multitouchmove');\n\n  /**\n   * Start of multitouch.\n   */\n  @Output() multitouchstart: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('multitouchstart');\n\n  /**\n   * Map options changed.\n   */\n  @Output() optionschange: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('optionschange');\n\n  /**\n   * Map size changed.\n   */\n  @Output() sizechange: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('sizechange');\n\n  /**\n   * The map type changed.\n   */\n  @Output() typechange: Observable<YaEvent<ymaps.Map>> =\n    this._eventManager.getLazyEmitter('typechange');\n\n  /**\n   * Mouse wheel scrolling.\n   */\n  @Output() yawheel: Observable<YaEvent<ymaps.Map>> = this._eventManager.getLazyEmitter('wheel');\n\n  constructor(\n    private readonly _ngZone: NgZone,\n    private readonly _yaApiLoaderService: YaApiLoaderService,\n    /*\n     * We need to use the same type like in an Angular.\n     * \"export declare const PLATFORM_ID: InjectionToken<Object>\"\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    @Inject(PLATFORM_ID) platformId: Object,\n  ) {\n    this.isBrowser = isPlatformBrowser(platformId);\n  }\n\n  /**\n   * Handles input changes and passes them in API.\n   * @param changes\n   */\n  ngOnChanges(changes: SimpleChanges): void {\n    const map = this.map$.value;\n\n    if (map) {\n      const { center, zoom, state, options } = changes;\n\n      if (state) {\n        this._setState(this._combineState(), map);\n      }\n\n      if (center) {\n        map.setCenter(center.currentValue);\n      }\n\n      if (zoom) {\n        map.setZoom(zoom.currentValue);\n      }\n\n      if (options) {\n        map.options.set(options.currentValue);\n      }\n    }\n  }\n\n  ngAfterViewInit(): void {\n    /**\n     * It should be a noop during server-side rendering.\n     */\n    if (this.isBrowser) {\n      const sub = this._yaApiLoaderService.load().subscribe(() => {\n        const id = generateRandomId();\n        const map = this._createMap(id);\n\n        this.map$.next(map);\n        this._eventManager.setTarget(map);\n        this._ngZone.run(() => this.ready.emit({ ymaps, target: map }));\n      });\n\n      this._sub.add(sub);\n    }\n  }\n\n  ngOnDestroy(): void {\n    this._eventManager.destroy();\n    this._sub.unsubscribe();\n  }\n\n  /**\n   * Destructs state and passes it in API.\n   * @param state\n   * @param map\n   */\n  private _setState(state: ymaps.IMapState, map: ymaps.Map): void {\n    const { behaviors, bounds, center, controls, margin, type, zoom } = state;\n\n    if (behaviors) {\n      map.behaviors.enable(behaviors);\n    }\n\n    if (bounds) {\n      map.setBounds(bounds);\n    }\n\n    if (center) {\n      map.setCenter(center);\n    }\n\n    if (controls) {\n      controls.forEach((control) => map.controls.add(control));\n    }\n\n    if (margin) {\n      map.margin.setDefaultMargin(margin);\n    }\n\n    if (type) {\n      map.setType(type);\n    }\n\n    if (zoom) {\n      map.setZoom(zoom);\n    }\n  }\n\n  /**\n   * Creates a map.\n   * @param id ID which will be set to the map container.\n   */\n  private _createMap(id: string): ymaps.Map {\n    const containerElem: HTMLElement = this.container.nativeElement;\n    containerElem.setAttribute('id', id);\n    containerElem.style.cssText = 'width: 100%; height: 100%;';\n\n    return new ymaps.Map(id, this._combineState(), this.options || {});\n  }\n\n  /**\n   * Combines the center and zoom into single object.\n   */\n  private _combineState(): ymaps.IMapState {\n    const state = this.state || {};\n\n    return {\n      ...state,\n      center: this.center || state.center || [0, 0],\n      zoom: this.zoom ?? state.zoom ?? 10,\n    };\n  }\n}\n","import {\n  Directive,\n  EventEmitter,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChanges,\n} from '@angular/core';\nimport { Observable, Subscription } from 'rxjs';\nimport { EventManager } from '../../event-manager';\nimport { YaMapComponent } from '../ya-map/ya-map.component';\nimport { YaReadyEvent } from '../../typings/ya-ready-event';\nimport { YaEvent } from '../../typings/ya-event';\n\n/**\n * The `ya-geoobject` component wraps `ymaps.GeoObject` class from the Yandex.Maps API.\n * You can configure it via the component's inputs.\n * Events can be bound using the outputs of the component.\n *\n * <example-url>https://stackblitz.com/edit/geoobject-polygon?embed=1</example-url>\n *\n * @example\n * ```html\n * <ya-map [center]=\"[55.761952, 37.620739]\">\n *   <ya-geoobject\n *     [feature]=\"{ geometry: { type: 'Rectangle', coordinates: [[55.665, 37.66], [55.64,37.53]] } }\"\n *   ></ya-geoobject>\n * </ya-map>\n * ```\n */\n@Directive({\n  selector: 'ya-geoobject',\n})\nexport class YaGeoObjectDirective implements OnInit, OnChanges, OnDestroy {\n  private readonly _sub = new Subscription();\n\n  private readonly _eventManager = new EventManager(this._ngZone);\n\n  geoObject?: ymaps.GeoObject;\n\n  /**\n   * Feature for the GeoObject.\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/GeoObject.html#GeoObjectparam-feature}\n   */\n  @Input() feature: ymaps.IGeoObjectFeature;\n\n  /**\n   * Options for the GeoObject.\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/GeoObject.html#GeoObjectparam-options}\n   */\n  @Input() options: ymaps.IGeoObjectOptions;\n\n  /**\n   * GeoObject instance is added in a Map.\n   */\n  @Output() ready: EventEmitter<YaReadyEvent<ymaps.GeoObject>> = new EventEmitter<\n    YaReadyEvent<ymaps.GeoObject>\n  >();\n\n  /**\n   * Closing the balloon.\n   */\n  @Output() balloonclose: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('balloonclose');\n\n  /**\n   * Opening a balloon on a map.\n   */\n  @Output() balloonopen: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('balloonopen');\n\n  /**\n   * Event preceding the \"drag\" event.\n   */\n  @Output() beforedrag: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('beforedrag');\n\n  /**\n   * Event preceding the \"dragstart\" event.\n   */\n  @Output() beforedragstart: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('beforedragstart');\n\n  /**\n   * Single left-click on the object.\n   */\n  @Output() yaclick: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('click');\n\n  /**\n   * Calls the element's context menu.\n   */\n  @Output() yacontextmenu: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('contextmenu');\n\n  /**\n   * Double left-click on the object.\n   */\n  @Output() yadblclick: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('dblclick');\n\n  /**\n   * Dragging a geo object.\n   */\n  @Output() yadrag: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('drag');\n\n  /**\n   * End of geo object dragging.\n   */\n  @Output() yadragend: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('dragend');\n\n  /**\n   * Start of geo object dragging.\n   */\n  @Output() yadragstart: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('dragstart');\n\n  /**\n   * Change in the state of the editor for the geo object's geometry.\n   */\n  @Output() editorstatechange: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('editorstatechange');\n\n  /**\n   * Change to the geo object geometry\n   */\n  @Output() geometrychange: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('geometrychange');\n\n  /**\n   * Closing the hint.\n   */\n  @Output() hintclose: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('hintclose');\n\n  /**\n   * Opening a hint on a map.\n   */\n  @Output() hintopen: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('hintopen');\n\n  /**\n   * Map reference changed.\n   */\n  @Output() mapchange: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('mapchange');\n\n  /**\n   * Pressing the mouse button over the object.\n   */\n  @Output() yamousedown: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('mousedown');\n\n  /**\n   * Pointing the cursor at the object.\n   */\n  @Output() yamouseenter: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('mouseenter');\n\n  /**\n   * Moving the cursor off of the object.\n   */\n  @Output() yamouseleave: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('mouseleave');\n\n  /**\n   * Moving the cursor over the object.\n   */\n  @Output() yamousemove: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('mousemove');\n\n  /**\n   * Letting go of the mouse button over an object.\n   */\n  @Output() yamouseup: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('mouseup');\n\n  /**\n   * End of multitouch.\n   */\n  @Output() multitouchend: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('multitouchend');\n\n  /**\n   * Repeating event during multitouch.\n   */\n  @Output() multitouchmove: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('multitouchmove');\n\n  /**\n   * Start of multitouch.\n   */\n  @Output() multitouchstart: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('multitouchstart');\n\n  /**\n   * Change to the object options.\n   */\n  @Output() optionschange: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('optionschange');\n\n  /**\n   * Change to the geo object overlay.\n   */\n  @Output() overlaychange: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('overlaychange');\n\n  /**\n   * The parent object reference changed.\n   */\n  @Output() parentchange: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('parentchange');\n\n  /**\n   * Change to the geo object data.\n   */\n  @Output() propertieschange: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('propertieschange');\n\n  /**\n   * Mouse wheel scrolling.\n   */\n  @Output() yawheel: Observable<YaEvent<ymaps.GeoObject>> =\n    this._eventManager.getLazyEmitter('wheel');\n\n  constructor(private readonly _ngZone: NgZone, private readonly _yaMapComponent: YaMapComponent) {}\n\n  /**\n   * Handles input changes and passes them in API.\n   * @param changes\n   */\n  ngOnChanges(changes: SimpleChanges): void {\n    const { geoObject } = this;\n\n    if (geoObject) {\n      const { feature, options } = changes;\n\n      if (feature) {\n        this._setFeature(feature.currentValue, geoObject);\n      }\n\n      if (options) {\n        geoObject.options.set(options.currentValue);\n      }\n    }\n  }\n\n  ngOnInit(): void {\n    if (this._yaMapComponent.isBrowser) {\n      const sub = this._yaMapComponent.map$.subscribe((map) => {\n        if (map) {\n          const geoObject = this._createGeoObject();\n          this.geoObject = geoObject;\n\n          map.geoObjects.add(geoObject);\n          this._eventManager.setTarget(geoObject);\n          this._ngZone.run(() => this.ready.emit({ ymaps, target: geoObject }));\n        }\n      });\n\n      this._sub.add(sub);\n    }\n  }\n\n  ngOnDestroy(): void {\n    if (this.geoObject) {\n      this._yaMapComponent?.map$.value?.geoObjects.remove(this.geoObject);\n      this._eventManager.destroy();\n    }\n\n    this._sub.unsubscribe();\n  }\n\n  /**\n   * Destructs feature and passes it in API.\n   * @param feature\n   * @param geoObject\n   */\n  private _setFeature(feature: ymaps.IGeoObjectFeature, geoObject: ymaps.GeoObject): void {\n    const { geometry, properties } = feature;\n\n    if (geometry) {\n      console.warn(\n        'The geometry can not be changed after entity init. To set it, you should recreate a GeoObject with new feature.geometry',\n      );\n    }\n\n    if (properties) {\n      geoObject.properties.set(properties);\n    }\n  }\n\n  /**\n   * Creates GeoObject.\n   */\n  private _createGeoObject(): ymaps.GeoObject {\n    return new ymaps.GeoObject(this.feature, this.options);\n  }\n}\n","import {\n  Directive,\n  EventEmitter,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChanges,\n} from '@angular/core';\nimport { Observable, Subscription } from 'rxjs';\nimport { YaMapComponent } from '../ya-map/ya-map.component';\nimport { EventManager } from '../../event-manager';\nimport { YaReadyEvent } from '../../typings/ya-ready-event';\nimport { YaEvent } from '../../typings/ya-event';\n\n/**\n * The `ya-placemark` directive wraps `ymaps.Placemark` class from the Yandex.Maps API.\n * You can configure it via the directive's inputs.\n * Events can be bound using the outputs of the directive.\n *\n * <example-url>https://stackblitz.com/edit/custom-placemark?embed=1</example-url>\n *\n * @example\n * ```html\n * <ya-map [center]=\"[55.751952, 37.600739]\">\n *   <ya-placemark [geometry]=\"[55.751952, 37.600739]\"></ya-placemark>\n * </ya-map>\n * ```\n */\n@Directive({\n  selector: 'ya-placemark',\n})\nexport class YaPlacemarkDirective implements OnInit, OnChanges, OnDestroy {\n  private readonly _sub = new Subscription();\n\n  private readonly _eventManager = new EventManager(this._ngZone);\n\n  placemark?: ymaps.Placemark;\n\n  /**\n   * Coordinates of the placemark, or a hash describing the geometry, or a reference to the point geometry object.\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/Placemark.html#Placemark__param-geometry}\n   */\n  @Input() geometry: number[] | object | ymaps.IPointGeometry;\n\n  /**\n   * Properties for the placemark.\n   * {@link https://yandex.com/maps/jsapi/doc/2.1/ref/reference/Placemark-docpage/#Placemarkparam-properties}\n   */\n  @Input() properties: ymaps.IPlacemarkProperties | ymaps.IDataManager;\n\n  /**\n   * Options for the placemark.\n   * {@link https://yandex.com/maps/jsapi/doc/2.1/ref/reference/Placemark-docpage/#Placemarkparam-options}\n   */\n  @Input() options: ymaps.IPlacemarkOptions;\n\n  /**\n   * Placemark instance is added in a Map.\n   */\n  @Output() ready: EventEmitter<YaReadyEvent<ymaps.Placemark>> = new EventEmitter<\n    YaReadyEvent<ymaps.Placemark>\n  >();\n\n  /**\n   * Closing the balloon.\n   */\n  @Output() balloonclose: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('balloonclose');\n\n  /**\n   * Opening a balloon on a map.\n   */\n  @Output() balloonopen: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('balloonopen');\n\n  /**\n   * Event preceding the \"drag\" event.\n   */\n  @Output() beforedrag: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('beforedrag');\n\n  /**\n   * Event preceding the \"dragstart\" event.\n   */\n  @Output() beforedragstart: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('beforedragstart');\n\n  /**\n   * Single left-click on the object.\n   */\n  @Output() yaclick: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('click');\n\n  /**\n   * Calls the element's context menu.\n   */\n  @Output() yacontextmenu: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('contextmenu');\n\n  /**\n   * Double left-click on the object.\n   */\n  @Output() yadblclick: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('dblclick');\n\n  /**\n   * Dragging a geo object.\n   */\n  @Output() yadrag: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('drag');\n\n  /**\n   * End of geo object dragging.\n   */\n  @Output() yadragend: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('dragend');\n\n  /**\n   * Start of geo object dragging.\n   */\n  @Output() yadragstart: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('dragstart');\n\n  /**\n   * Change in the state of the editor for the geo object's geometry.\n   */\n  @Output() editorstatechange: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('editorstatechange');\n\n  /**\n   * Change to the geo object geometry\n   */\n  @Output() geometrychange: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('geometrychange');\n\n  /**\n   * Closing the hint.\n   */\n  @Output() hintclose: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('hintclose');\n\n  /**\n   * Opening a hint on a map.\n   */\n  @Output() hintopen: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('hintopen');\n\n  /**\n   * Map reference changed.\n   */\n  @Output() mapchange: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('mapchange');\n\n  /**\n   * Pressing the mouse button over the object.\n   */\n  @Output() yamousedown: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('mousedown');\n\n  /**\n   * Pointing the cursor at the object.\n   */\n  @Output() yamouseenter: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('mouseenter');\n\n  /**\n   * Moving the cursor off of the object.\n   */\n  @Output() yamouseleave: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('mouseleave');\n\n  /**\n   * Moving the cursor over the object.\n   */\n  @Output() yamousemove: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('mousemove');\n\n  /**\n   * Letting go of the mouse button over an object.\n   */\n  @Output() yamouseup: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('mouseup');\n\n  /**\n   * End of multitouch.\n   */\n  @Output() multitouchend: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('multitouchend');\n\n  /**\n   * Repeating event during multitouch.\n   */\n  @Output() multitouchmove: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('multitouchmove');\n\n  /**\n   * Start of multitouch.\n   */\n  @Output() multitouchstart: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('multitouchstart');\n\n  /**\n   * Change to the object options.\n   */\n  @Output() optionschange: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('optionschange');\n\n  /**\n   * Change to the geo object overlay.\n   */\n  @Output() overlaychange: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('overlaychange');\n\n  /**\n   * The parent object reference changed.\n   */\n  @Output() parentchange: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('parentchange');\n\n  /**\n   * Change to the geo object data.\n   */\n  @Output() propertieschange: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('propertieschange');\n\n  /**\n   * Mouse wheel scrolling.\n   */\n  @Output() yawheel: Observable<YaEvent<ymaps.Placemark>> =\n    this._eventManager.getLazyEmitter('wheel');\n\n  constructor(private readonly _ngZone: NgZone, private readonly _yaMapComponent: YaMapComponent) {}\n\n  /**\n   * Handles input changes and passes them in API.\n   * @param changes\n   */\n  ngOnChanges(changes: SimpleChanges): void {\n    const { placemark } = this;\n\n    if (placemark) {\n      const { geometry, properties, options } = changes;\n\n      if (geometry) {\n        placemark.geometry?.setCoordinates(geometry.currentValue);\n      }\n\n      if (properties) {\n        placemark.properties.set(properties.currentValue);\n      }\n\n      if (options) {\n        placemark.options.set(options.currentValue);\n      }\n    }\n  }\n\n  ngOnInit(): void {\n    if (this._yaMapComponent.isBrowser) {\n      const sub = this._yaMapComponent.map$.subscribe((map) => {\n        if (map) {\n          const placemark = this._createPlacemark();\n          this.placemark = placemark;\n\n          map.geoObjects.add(placemark);\n          this._eventManager.setTarget(placemark);\n          this._ngZone.run(() => this.ready.emit({ ymaps, target: placemark }));\n        }\n      });\n\n      this._sub.add(sub);\n    }\n  }\n\n  ngOnDestroy(): void {\n    if (this.placemark) {\n      this._yaMapComponent?.map$.value?.geoObjects.remove(this.placemark);\n      this._eventManager.destroy();\n    }\n\n    this._sub.unsubscribe();\n  }\n\n  /**\n   * Creates a placemark.\n   */\n  private _createPlacemark(): ymaps.Placemark {\n    return new ymaps.Placemark(this.geometry, this.properties, this.options);\n  }\n}\n","import {\n  AfterContentInit,\n  ChangeDetectionStrategy,\n  Component,\n  ContentChildren,\n  EventEmitter,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Output,\n  QueryList,\n  SimpleChanges,\n} from '@angular/core';\nimport { Observable, Subscription } from 'rxjs';\nimport { YaGeoObjectDirective } from '../ya-geoobject/ya-geoobject.directive';\nimport { YaMapComponent } from '../ya-map/ya-map.component';\nimport { YaPlacemarkDirective } from '../ya-placemark/ya-placemark.directive';\nimport { EventManager } from '../../event-manager';\nimport { YaReadyEvent } from '../../typings/ya-ready-event';\nimport { YaEvent } from '../../typings/ya-event';\n\n/**\n * The `ya-clusterer` component wraps `ymaps.Clusterer` class from the Yandex.Maps API.\n * You can configure it via the component's inputs.\n * Events can be bound using the outputs of the component.\n *\n * <example-url>https://stackblitz.com/edit/placemark-clusterer?embed=1</example-url>\n *\n * @example\n * ```html\n * <ya-map [center]=\"[55.761952, 37.620739]\">\n *   <ya-clusterer [options]=\"{ minClusterSize: 5 }\">\n *     <ya-placemark [geometry]=\"[55.74, 37.5]\"></ya-placemark>\n *     <ya-placemark [geometry]=\"[55.64, 37.46]\"></ya-placemark>\n *     <ya-placemark [geometry]=\"[55.75, 37.38]\"></ya-placemark>\n *\n *     <ya-geoobject\n *       [feature]=\"{ geometry: { type: 'Point', coordinates: [55.81, 37.4] } }\"\n *      ></ya-geoobject>\n *\n *     <ya-geoobject\n *       [feature]=\"{ geometry: { type: 'Point', coordinates: [55.7, 37.39] } }\"\n *      ></ya-geoobject>\n *   </ya-clusterer>\n * </ya-map>\n * ```\n */\n@Component({\n  selector: 'ya-clusterer',\n  template: '<ng-content></ng-content>',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class YaClustererComponent implements AfterContentInit, OnChanges, OnDestroy {\n  @ContentChildren(YaPlacemarkDirective)\n  private readonly _placemarks: QueryList<YaPlacemarkDirective>;\n\n  @ContentChildren(YaGeoObjectDirective)\n  private readonly _geoObjects: QueryList<YaGeoObjectDirective>;\n\n  private readonly _sub = new Subscription();\n\n  private readonly _eventManager = new EventManager(this._ngZone);\n\n  private _clusterer?: ymaps.Clusterer;\n\n  /**\n   * Options for the clusterer.\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/Clusterer.html#Clusterer__param-options}\n   */\n  @Input() options: ymaps.IClustererOptions;\n\n  /**\n   * Clusterer instance is added in a Map.\n   */\n  @Output() ready: EventEmitter<YaReadyEvent<ymaps.Clusterer>> = new EventEmitter<\n    YaReadyEvent<ymaps.Clusterer>\n  >();\n\n  /**\n   * Closing the hint.\n   */\n  @Output() hintclose: Observable<YaEvent<ymaps.Clusterer>> =\n    this._eventManager.getLazyEmitter('hintclose');\n\n  /**\n   * Opening a hint on a map.\n   */\n  @Output() hintopen: Observable<YaEvent<ymaps.Clusterer>> =\n    this._eventManager.getLazyEmitter('hintopen');\n\n  /**\n   * Map reference changed.\n   */\n  @Output() mapchange: Observable<YaEvent<ymaps.Clusterer>> =\n    this._eventManager.getLazyEmitter('mapchange');\n\n  /**\n   * Change to the object options.\n   */\n  @Output() optionschange: Observable<YaEvent<ymaps.Clusterer>> =\n    this._eventManager.getLazyEmitter('optionschange');\n\n  /**\n   * The parent object reference changed.\n   */\n  @Output() parentchange: Observable<YaEvent<ymaps.Clusterer>> =\n    this._eventManager.getLazyEmitter('parentchange');\n\n  constructor(private readonly _ngZone: NgZone, private readonly _yaMapComponent: YaMapComponent) {}\n\n  /**\n   * Handles input changes and passes them in API.\n   * @param changes\n   */\n  ngOnChanges(changes: SimpleChanges): void {\n    const clusterer = this._clusterer;\n\n    if (clusterer) {\n      const { options } = changes;\n\n      if (options) {\n        clusterer.options.set(options.currentValue);\n      }\n    }\n  }\n\n  ngAfterContentInit(): void {\n    if (this._yaMapComponent.isBrowser) {\n      const sub = this._yaMapComponent.map$.subscribe((map) => {\n        if (map) {\n          const clusterer = this._createClusterer();\n          this._clusterer = clusterer;\n\n          map.geoObjects.add(clusterer);\n          this._eventManager.setTarget(clusterer);\n          this._watchForContentChanges(clusterer);\n          this._ngZone.run(() => this.ready.emit({ ymaps, target: clusterer }));\n        }\n      });\n\n      this._sub.add(sub);\n    }\n  }\n\n  ngOnDestroy(): void {\n    this._eventManager.destroy();\n    this._sub.unsubscribe();\n  }\n\n  /**\n   * Creates Clusterer.\n   */\n  private _createClusterer(): ymaps.Clusterer {\n    return new ymaps.Clusterer(this.options);\n  }\n\n  private _watchForContentChanges(clusterer: ymaps.Clusterer): void {\n    /**\n     * Adds new Placemarks to the clusterer on changes.\n     */\n    const currentPlacemarks = new Set<ymaps.Placemark>();\n\n    this._getInternalPlacemarks(this._placemarks.toArray()).forEach((placemark) => {\n      currentPlacemarks.add(placemark);\n      clusterer.add(placemark);\n    });\n\n    const placemarksSub = this._placemarks.changes.subscribe(\n      (placemarkDirectives: YaPlacemarkDirective[]) => {\n        const newPlacemarks = new Set<ymaps.Placemark>(\n          this._getInternalPlacemarks(placemarkDirectives),\n        );\n\n        const difference = this._getDifference<ymaps.Placemark>(newPlacemarks, currentPlacemarks);\n\n        clusterer.add(difference.toAdd);\n        clusterer.remove(difference.toRemove);\n      },\n    );\n\n    this._sub.add(placemarksSub);\n\n    /**\n     * Adds new GeoObjects to the clusterer on changes.\n     */\n    const currentGeoObjects = new Set<ymaps.GeoObject>();\n\n    this._getInternalGeoObjects(this._geoObjects.toArray()).forEach((geoObject) => {\n      currentGeoObjects.add(geoObject);\n      clusterer.add(geoObject);\n    });\n\n    const geoObjectsSub = this._geoObjects.changes.subscribe(\n      (geoObjectDirectives: YaGeoObjectDirective[]) => {\n        const newGeoObjects = new Set<ymaps.GeoObject>(\n          this._getInternalGeoObjects(geoObjectDirectives),\n        );\n\n        const difference = this._getDifference<ymaps.GeoObject>(newGeoObjects, currentGeoObjects);\n\n        clusterer.add(difference.toAdd);\n        clusterer.remove(difference.toRemove);\n      },\n    );\n\n    this._sub.add(geoObjectsSub);\n  }\n\n  /**\n   * Determines what should be added/removed in current set to equal new set\n   *\n   * @param newSet\n   * @param currentSet\n   */\n  private _getDifference<T>(newSet: Set<T>, currentSet: Set<T>) {\n    const toAdd: T[] = [];\n    const toRemove: T[] = [];\n\n    newSet.forEach((component) => {\n      if (!currentSet.has(component)) {\n        toAdd.push(component);\n        currentSet.add(component);\n      }\n    });\n\n    currentSet.forEach((component) => {\n      if (!newSet.has(component)) {\n        toRemove.push(component);\n        currentSet.delete(component);\n      }\n    });\n\n    return {\n      toAdd,\n      toRemove,\n    };\n  }\n\n  private _getInternalPlacemarks(placemarks: YaPlacemarkDirective[]): ymaps.Placemark[] {\n    return placemarks\n      .filter((component) => !!component.placemark)\n      .map((component) => component.placemark!);\n  }\n\n  private _getInternalGeoObjects(geoObjects: YaGeoObjectDirective[]): ymaps.GeoObject[] {\n    return geoObjects\n      .filter((component) => !!component.geoObject)\n      .map((component) => component.geoObject!);\n  }\n}\n","import {\n  Directive,\n  EventEmitter,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n} from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { YaMapComponent } from '../ya-map/ya-map.component';\nimport { YaReadyEvent } from '../../typings/ya-ready-event';\n\n/**\n * Control types.\n */\nexport type YaControlType =\n  | 'Button'\n  | 'FullscreenControl'\n  | 'GeolocationControl'\n  | 'ListBox'\n  | 'ListBoxItem'\n  | 'RouteButton'\n  | 'RouteEditor'\n  | 'RoutePanel'\n  | 'RulerControl'\n  | 'SearchControl'\n  | 'TrafficControl'\n  | 'TypeSelector'\n  | 'ZoomControl';\n\n/**\n * The `ya-control` component wraps `ymaps.control[YaControlType]` classes from the Yandex.Maps API.\n * You can configure `ymaps.control[YaControlType]` via the component's inputs.\n * API Events can be bound only manually. You can use `ready` event to get an instance.\n *\n * <example-url>https://stackblitz.com/edit/searchcontrol?embed=1</example-url>\n *\n * @example\n * ```html\n * <ya-map [center]=\"[55.761952, 37.620739]\">\n *   <ya-control\n *     type=\"RoutePanel\"\n *     [parameters]=\"{ options: { float: 'right' } }\"\n *   ></ya-control>\n * </ya-map>\n * ```\n */\n@Directive({\n  selector: 'ya-control',\n})\nexport class YaControlDirective implements OnInit, OnChanges, OnDestroy {\n  private readonly _sub = new Subscription();\n\n  private _control?: any;\n\n  /**\n   * Control type.\n   */\n  @Input() type: YaControlType;\n\n  /**\n   * Parameters for the Control.\n   */\n  @Input() parameters: any;\n\n  /**\n   * Control instance is added in a Map.\n   */\n  @Output() ready: EventEmitter<YaReadyEvent<any>> = new EventEmitter<YaReadyEvent<any>>();\n\n  constructor(private readonly _ngZone: NgZone, private readonly _yaMapComponent: YaMapComponent) {}\n\n  ngOnChanges(): void {\n    if (this._control) {\n      console.warn(\n        'Control does not support dynamic configuration. You can config it manually using ymaps or recreate the component with new configuration',\n      );\n    }\n  }\n\n  ngOnInit(): void {\n    if (this._yaMapComponent.isBrowser) {\n      const sub = this._yaMapComponent.map$.subscribe((map) => {\n        if (map) {\n          const control = new ymaps.control[this.type](this.parameters);\n          this._control = control;\n\n          /**\n           * RoutePanel ignores state in parameters. API bug\n           */\n          if (\n            control instanceof ymaps.control.RoutePanel &&\n            this.parameters &&\n            this.parameters.state\n          ) {\n            control.routePanel.state.set({ ...this.parameters.state });\n          }\n\n          map.controls.add(control);\n          this._ngZone.run(() => this.ready.emit({ ymaps, target: control }));\n        }\n      });\n\n      this._sub.add(sub);\n    }\n  }\n\n  ngOnDestroy(): void {\n    if (this._control) {\n      this._yaMapComponent?.map$.value?.controls.remove(this._control);\n    }\n  }\n}\n","import {\n  Directive,\n  EventEmitter,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChanges,\n} from '@angular/core';\nimport { Observable, Subscription } from 'rxjs';\nimport { EventManager } from '../../event-manager';\nimport { YaMapComponent } from '../ya-map/ya-map.component';\nimport { YaReadyEvent } from '../../typings/ya-ready-event';\nimport { YaEvent } from '../../typings/ya-event';\n\n/**\n * @internal\n */\ntype Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\n\n/**\n * The `ya-multiroute` component wraps `ymaps.multiRouter.MultiRoute` class from the Yandex.Maps API.\n * You can configure it via the component's inputs.\n * Events can be bound using the outputs of the component.\n *\n * <example-url>https://stackblitz.com/edit/multiroute-pedestrian?embed=1</example-url>\n *\n * @example\n * ```html\n * <ya-map [center]=\"[55.761952, 37.620739]\">\n *   <ya-multiroute\n *     [referencePoints]=\"[[55.751952, 37.600739], ' , ']\"\n *     [model]=\"{ params: { routingMode: 'pedestrian' } }\"\n *   ></ya-multiroute>\n * </ya-map>\n * ```\n */\n@Directive({\n  selector: 'ya-multiroute',\n})\nexport class YaMultirouteDirective implements OnInit, OnChanges, OnDestroy {\n  private readonly _sub = new Subscription();\n\n  private readonly _eventManager = new EventManager(this._ngZone);\n\n  private _multiroute?: ymaps.multiRouter.MultiRoute;\n\n  /**\n   * Reference points for the multiroute.\n   * Shorthand for [model]=\"{ referencePoints: [0, 0] }\".\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/IMultiRouteReferencePoint.html}\n   */\n  @Input() referencePoints: ymaps.IMultiRouteReferencePoint[];\n\n  /**\n   * Model description object of a multiroute.\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/IMultiRouteModelJson.html}\n   */\n  @Input() model:\n    | ymaps.multiRouter.MultiRouteModel\n    | Optional<ymaps.IMultiRouteModelJson, 'referencePoints'>;\n\n  /**\n   * Options for the multiroute.\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/multiRouter.MultiRoute.html#multiRouter.MultiRoute__param-options}\n   */\n  @Input() options: ymaps.multiRouter.IMultiRouteOptions;\n\n  /**\n   * Multiroute instance is added in a Map.\n   */\n  @Output() ready: EventEmitter<YaReadyEvent<ymaps.multiRouter.MultiRoute>> = new EventEmitter<\n    YaReadyEvent<ymaps.multiRouter.MultiRoute>\n  >();\n\n  /**\n   * Change to the active route.\n   */\n  @Output() activeroutechange: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('activeroutechange');\n\n  /**\n   * Closing the balloon.\n   */\n  @Output() balloonclose: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('balloonclose');\n\n  /**\n   * Opening a balloon on a map.\n   */\n  @Output() balloonopen: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('balloonopen');\n\n  /**\n   * The event occurs at the time of setting the map center and its zoom level for optimal display of the multi-route.\n   */\n  @Output() boundsautoapply: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('boundsautoapply');\n\n  /**\n   * Changing coordinates of the geographical area covering the multi-route.\n   */\n  @Output() boundschange: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('boundschange');\n\n  /**\n   * Single left-click on the object.\n   */\n  @Output() yaclick: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('click');\n\n  /**\n   * Calls the element's context menu.\n   */\n  @Output() yacontextmenu: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('contextmenu');\n\n  /**\n   * Double left-click on the object.\n   */\n  @Output() yadblclick: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('dblclick');\n\n  /**\n   * Change to the geo object geometry.\n   */\n  @Output() geometrychange: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('geometrychange');\n\n  /**\n   * Map reference changed.\n   */\n  @Output() mapchange: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('mapchange');\n\n  /**\n   * Pressing the mouse button over the object.\n   */\n  @Output() yamousedown: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('mousedown');\n\n  /**\n   * Pointing the cursor at the object.\n   */\n  @Output() yamouseenter: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('mouseenter');\n\n  /**\n   * Moving the cursor off of the object.\n   */\n  @Output() yamouseleave: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('mouseleave');\n\n  /**\n   * Moving the cursor over the object.\n   */\n  @Output() yamousemove: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('mousemove');\n\n  /**\n   * Letting go of the mouse button over an object.\n   */\n  @Output() yamouseup: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('mouseup');\n\n  /**\n   * End of multitouch.\n   */\n  @Output() multitouchend: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('multitouchend');\n\n  /**\n   * Repeating event during multitouch.\n   */\n  @Output() multitouchmove: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('multitouchmove');\n\n  /**\n   * Start of multitouch.\n   */\n  @Output() multitouchstart: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('multitouchstart');\n\n  /**\n   * Change to the object options.\n   */\n  @Output() optionschange: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('optionschange');\n\n  /**\n   * Change to the geo object overlay.\n   */\n  @Output() overlaychange: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('overlaychange');\n\n  /**\n   * The parent object reference changed.\n   */\n  @Output() parentchange: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('parentchange');\n\n  /**\n   * Changing pixel coordinates of the area covering the multi-route.\n   */\n  @Output() pixelboundschange: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('pixelboundschange');\n\n  /**\n   * Change to the geo object data.\n   */\n  @Output() propertieschange: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('propertieschange');\n\n  /**\n   * Updating the multi-route.\n   */\n  @Output() update: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('update');\n\n  /**\n   * Mouse wheel scrolling.\n   */\n  @Output() yawheel: Observable<YaEvent<ymaps.multiRouter.MultiRoute>> =\n    this._eventManager.getLazyEmitter('wheel');\n\n  constructor(private readonly _ngZone: NgZone, private readonly _yaMapComponent: YaMapComponent) {}\n\n  /**\n   * Handles input changes and passes them in API.\n   * @param changes\n   */\n  ngOnChanges(changes: SimpleChanges): void {\n    const multiroute = this._multiroute;\n\n    if (multiroute) {\n      const { referencePoints, model, options } = changes;\n\n      if (model) {\n        this._setModel(model.currentValue, multiroute);\n      }\n\n      if (referencePoints) {\n        multiroute.model.setReferencePoints(referencePoints.currentValue);\n      }\n\n      if (options) {\n        multiroute.options.set(options.currentValue);\n      }\n    }\n  }\n\n  ngOnInit(): void {\n    if (this._yaMapComponent.isBrowser) {\n      const sub = this._yaMapComponent.map$.subscribe((map) => {\n        if (map) {\n          const multiroute = this._createMultiroute();\n          this._multiroute = multiroute;\n\n          map.geoObjects.add(multiroute);\n          this._eventManager.setTarget(multiroute);\n          this._ngZone.run(() => this.ready.emit({ ymaps, target: multiroute }));\n        }\n      });\n\n      this._sub.add(sub);\n    }\n  }\n\n  ngOnDestroy(): void {\n    if (this._multiroute) {\n      this._yaMapComponent?.map$.value?.geoObjects.remove(this._multiroute);\n      this._eventManager.destroy();\n    }\n\n    this._sub.unsubscribe();\n  }\n\n  /**\n   * Destructs state and passes them in API.\n   * @param model\n   * @param multiroute\n   */\n  private _setModel(\n    model: ymaps.IMultiRouteModelJson,\n    multiroute: ymaps.multiRouter.MultiRoute,\n  ): void {\n    const { referencePoints, params } = model;\n\n    if (referencePoints) {\n      multiroute.model.setReferencePoints(referencePoints);\n    }\n\n    if (params) {\n      multiroute.model.setParams(params);\n    }\n  }\n\n  /**\n   * Creates Multiroute.\n   */\n  private _createMultiroute(): ymaps.multiRouter.MultiRoute {\n    return new ymaps.multiRouter.MultiRoute(this._combineModel(), this.options);\n  }\n\n  /**\n   * Combines the model and reference points into single object\n   */\n  private _combineModel(): ymaps.IMultiRouteModelJson {\n    const model = (this.model || {}) as ymaps.IMultiRouteModelJson;\n\n    return {\n      ...model,\n      referencePoints: this.referencePoints || model.referencePoints,\n    };\n  }\n}\n","import {\n  Directive,\n  EventEmitter,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChanges,\n} from '@angular/core';\nimport { from, Observable, Subscription } from 'rxjs';\nimport { filter, map, switchMap } from 'rxjs/operators';\nimport { EventManager } from '../../event-manager';\nimport { YaMapComponent } from '../ya-map/ya-map.component';\nimport { YaReadyEvent } from '../../typings/ya-ready-event';\nimport { YaEvent } from '../../typings/ya-event';\n\n/**\n * The `ya-panorama` component wraps `ymaps.panorama.Player` class from the Yandex.Maps API.\n * You can configure it via the component's inputs.\n * Events can be bound using the outputs of the component.\n *\n * <example-url>https://stackblitz.com/edit/panorama?embed=1</example-url>\n *\n * @example\n * ```html\n * <ya-map>\n *   <ya-panorama [point]=\"[59.938557, 30.316198]\" layer=\"yandex#airPanorama\"></ya-panorama>\n * </ya-map>\n * ```\n */\n@Directive({\n  selector: 'ya-panorama',\n})\nexport class YaPanoramaDirective implements OnInit, OnChanges, OnDestroy {\n  private readonly _sub = new Subscription();\n\n  private readonly _eventManager = new EventManager(this._ngZone);\n\n  private _player?: ymaps.panorama.Player;\n\n  /**\n   * The point for searching for nearby panoramas.\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/panorama.locate.html#panorama.locate__param-point}\n   */\n  @Input() point: number[];\n\n  /**\n   * The layer to search for panoramas.\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/panorama.locate.html#panorama.locate__param-options.layer}\n   */\n  @Input() layer: ymaps.panorama.Layer;\n\n  /**\n   * Options for the player.\n   * {@link https://yandex.com/dev/maps/jsapi/doc/2.1/ref/reference/panorama.Player.html#panorama.Player__param-options}\n   */\n  @Input() options: ymaps.panorama.IPlayerOptions;\n\n  /**\n   * Panorama instance is created.\n   */\n  @Output() ready: EventEmitter<YaReadyEvent<ymaps.panorama.Player>> = new EventEmitter<\n    YaReadyEvent<ymaps.panorama.Player>\n  >();\n\n  /**\n   * The player was closed by the user or destroyed using the panorama.Player.destroy method.\n   */\n  @Output() destroy: Observable<YaEvent<ymaps.panorama.Player>> =\n    this._eventManager.getLazyEmitter('destroy');\n\n  /**\n   * The view direction changed.\n   */\n  @Output() directionchange: Observable<YaEvent<ymaps.panorama.Player>> =\n    this._eventManager.getLazyEmitter('directionchange');\n\n  /**\n   * An error occurred during operation of the player. The user will be shown the appropriate screen.\n   */\n  @Output() yaerror: Observable<YaEvent<ymaps.panorama.Player>> =\n    this._eventManager.getLazyEmitter('error');\n\n  /**\n   * The panorama player switched to full-screen mode.\n   */\n  @Output() fullscreenenter: Observable<YaEvent<ymaps.panorama.Player>> =\n    this._eventManager.getLazyEmitter('fullscreenenter');\n\n  /**\n   * The panorama player exited full-screen mode.\n   */\n  @Output() fullscreenexit: Observable<YaEvent<ymaps.panorama.Player>> =\n    this._eventManager.getLazyEmitter('fullscreenexit');\n\n  /**\n   * The user clicked on an expanded marker.\n   */\n  @Output() markercollapse: Observable<YaEvent<ymaps.panorama.Player>> =\n    this._eventManager.getLazyEmitter('markercollapse');\n\n  /**\n   * The user clicked on a collapsed marker.\n   */\n  @Output() markerexpand: Observable<YaEvent<ymaps.panorama.Player>> =\n    this._eventManager.getLazyEmitter('markerexpand');\n\n  /**\n   * The user's cursor hovered over a marker.\n   */\n  @Output() markermouseenter: Observable<YaEvent<ymaps.panorama.Player>> =\n    this._eventManager.getLazyEmitter('markermouseenter');\n\n  /**\n   * The user's cursor left a marker.\n   */\n  @Output() markermouseleave: Observable<YaEvent<ymaps.panorama.Player>> =\n    this._eventManager.getLazyEmitter('markermouseleave');\n\n  /**\n   * The open panorama changed.\n   */\n  @Output() panoramachange: Observable<YaEvent<ymaps.panorama.Player>> =\n    this._eventManager.getLazyEmitter('panoramachange');\n\n  /**\n   * The size of the viewport has been changed.\n   */\n  @Output() spanchange: Observable<YaEvent<ymaps.panorama.Player>> =\n    this._eventManager.getLazyEmitter('spanchange');\n\n  constructor(private readonly _ngZone: NgZone, private readonly _yaMapComponent: YaMapComponent) {}\n\n  /**\n   * Handles input changes and passes them in API.\n   * @param changes\n   */\n  ngOnChanges(changes: SimpleChanges): void {\n    const player = this._player;\n\n    if (player) {\n      const { point, layer, options } = changes;\n\n      /**\n       * player.moveTo resets values to default if any of them isn't passed.\n       * That's why we use value from currentValue OR previous value from input.\n       * With that logic it's possible to pass only point, layer or options.\n       */\n      if (point || layer) {\n        const combinedPoint: number[] = point?.currentValue || this.point;\n        const combinedLayer: ymaps.panorama.Layer = layer?.currentValue || this.layer;\n\n        player.moveTo(combinedPoint, { layer: combinedLayer });\n      }\n\n      if (options) {\n        this._setOptions(options.currentValue, player);\n      }\n    }\n  }\n\n  ngOnInit(): void {\n    if (this._yaMapComponent.isBrowser) {\n      const panorama$ = this._yaMapComponent.map$.pipe(\n        filter((m): m is ymaps.Map => Boolean(m)),\n        switchMap((m: ymaps.Map) => {\n          /**\n           * Map and panorama use the same container, so need to destroy/remove map\n           */\n          m.destroy();\n          return this._createPanorama();\n        }),\n      );\n\n      const sub = panorama$.subscribe((panorama) => {\n        const { id } = this._yaMapComponent.container.nativeElement;\n        const player = new ymaps.panorama.Player(id, panorama, this.options);\n        this._player = player;\n\n        this._eventManager.setTarget(player);\n        this._ngZone.run(() => this.ready.emit({ ymaps, target: player }));\n      });\n\n      this._sub.add(sub);\n    }\n  }\n\n  ngOnDestroy(): void {\n    this._eventManager.destroy();\n    this._sub.unsubscribe();\n  }\n\n  /**\n   * Destructs state and passes it in API.\n   * @param options\n   * @param player\n   */\n  private _setOptions(options: ymaps.panorama.IPlayerOptions, player: ymaps.panorama.Player): void {\n    const {\n      autoFitToViewport,\n      controls,\n      direction,\n      hotkeysEnabled,\n      span,\n      scrollZoomBehavior,\n      suppressMapOpenBlock,\n    } = options;\n\n    if (\n      autoFitToViewport ||\n      controls ||\n      hotkeysEnabled ||\n      scrollZoomBehavior ||\n      suppressMapOpenBlock\n    ) {\n      console.warn(\n        'Only direction and span can be set after entity init. To set other options, you should recreate a Panorama with new options',\n      );\n    }\n\n    if (direction) {\n      player.setDirection(direction);\n    }\n\n    if (span) {\n      player.setSpan(span);\n    }\n  }\n\n  /**\n   * Searches for a panorama and returns first\n   */\n  private _createPanorama(): Observable<ymaps.IPanorama> {\n    return from(ymaps.panorama.locate(this.point, { layer: this.layer })).pipe(\n      map((panoramas) => panoramas[0]),\n    );\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\n\nimport { YA_CONFIG, YaConfig } from './services/ya-api-loader/ya-api-loader.service';\n\nimport { YaClustererComponent } from './components/ya-clusterer/ya-clusterer.component';\nimport { YaControlDirective } from './components/ya-control/ya-control.directive';\nimport { YaGeoObjectDirective } from './components/ya-geoobject/ya-geoobject.directive';\nimport { YaMapComponent } from './components/ya-map/ya-map.component';\nimport { YaMultirouteDirective } from './components/ya-multiroute/ya-multiroute.directive';\nimport { YaPanoramaDirective } from './components/ya-panorama/ya-panorama.directive';\nimport { YaPlacemarkDirective } from './components/ya-placemark/ya-placemark.directive';\n\n@NgModule({\n  declarations: [\n    YaClustererComponent,\n    YaControlDirective,\n    YaGeoObjectDirective,\n    YaMapComponent,\n    YaMultirouteDirective,\n    YaPanoramaDirective,\n    YaPlacemarkDirective,\n  ],\n  exports: [\n    YaClustererComponent,\n    YaControlDirective,\n    YaGeoObjectDirective,\n    YaMapComponent,\n    YaMultirouteDirective,\n    YaPanoramaDirective,\n    YaPlacemarkDirective,\n  ],\n})\nexport class AngularYandexMapsModule {\n  /**\n   * Please use this method when you register the module at the root level\n   * @param config\n   */\n  static forRoot(config: YaConfig): ModuleWithProviders<AngularYandexMapsModule> {\n    return {\n      ngModule: AngularYandexMapsModule,\n      providers: [{ provide: YA_CONFIG, useValue: config }],\n    };\n  }\n}\n","import { Injectable, NgZone } from '@angular/core';\nimport { switchMap } from 'rxjs/operators';\nimport { from, Observable } from 'rxjs';\nimport { YaApiLoaderService } from '../ya-api-loader/ya-api-loader.service';\n\n/**\n * The `YaGeocoder` service wraps `ymaps.geocode` static function from the Yandex.Maps API.\n *\n * @example\n * ```ts\n * import { YaGeocoderService } from 'angular8-yandex-maps';\n *\n * export class AppComponent {\n *   constructor(private yaGeocoderService: YaGeocoderService) {\n *     this.yaGeocoderService.geocode('Moscow')\n *       .subscribe(v => console.log(v))\n *   }\n * }\n * ```\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class YaGeocoderService {\n  constructor(\n    private readonly _ngZone: NgZone,\n    private readonly _yaApiLoaderService: YaApiLoaderService,\n  ) {}\n\n  /**\n   * Processes geocoding requests.\n   * @param request The address for which coordinates need to be obtained (forward geocoding), or the coordinates for which the address needs to be determined (reverse geocoding).\n   * @param options Options.\n   */\n  geocode(request: string | number[], options?: ymaps.IGeocodeOptions): Observable<object> {\n    return this._yaApiLoaderService.load().pipe(\n      switchMap(() => from(ymaps.geocode(request, options))),\n      switchMap(\n        (result) =>\n          new Observable<object>((observer) => {\n            this._ngZone.run(() => {\n              observer.next(result);\n              observer.complete();\n            });\n          }),\n      ),\n    );\n  }\n}\n","/*\n * Public API Surface of angular8-yandex-maps\n */\n\n// Typings\nimport './lib/typings/yandex-maps/index';\n\n// Module\nexport * from './lib/angular-yandex-maps.module';\n\n// Services\nexport * from './lib/services/ya-api-loader/ya-api-loader.service';\nexport * from './lib/services/ya-geocoder/ya-geocoder.service';\n\n// Interfaces\nexport * from './lib/typings/ya-event';\nexport * from './lib/typings/ya-ready-event';\n\n// Components\nexport * from './lib/components/ya-clusterer/ya-clusterer.component';\nexport * from './lib/components/ya-control/ya-control.directive';\nexport * from './lib/components/ya-geoobject/ya-geoobject.directive';\nexport * from './lib/components/ya-map/ya-map.component';\nexport * from './lib/components/ya-multiroute/ya-multiroute.directive';\nexport * from './lib/components/ya-panorama/ya-panorama.directive';\nexport * from './lib/components/ya-placemark/ya-placemark.directive';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}